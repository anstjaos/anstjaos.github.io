<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-01-30T15:45:13+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">노력하는 개발자의 블로그</title><subtitle>백엔드 개발자</subtitle><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><entry><title type="html">Promise, Async, Await</title><link href="http://localhost:4000/study/promise-async-await/" rel="alternate" type="text/html" title="Promise, Async, Await" /><published>2021-01-14T00:00:00+09:00</published><updated>2021-01-14T00:00:00+09:00</updated><id>http://localhost:4000/study/promise-async-await</id><content type="html" xml:base="http://localhost:4000/study/promise-async-await/">&lt;h1 id=&quot;promise와-async-await&quot;&gt;Promise와 async, await&lt;/h1&gt;

&lt;p&gt;ES2015부터 Promise가 정식적으로 지원된다.&lt;/p&gt;

&lt;p&gt;Promise는 기존의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callback 지옥&lt;/code&gt;을 벗어나는데 큰 도움을 준다.&lt;/p&gt;

&lt;p&gt;예를 들어 다음과 같은 코드가 있다고 가정한다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updateUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;updatedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updatedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;deleteUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;deleteUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 끝도 없이 함수가 깊어지고 depth가 깊어지는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callback 지옥&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;이를 방지하고자 Promise라는 것이 새로 나오게 되었는데&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;success&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;성공&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;실패&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updateUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updatedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updatedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;deleteUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updatedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;deletedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;deletedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
	&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;내가 제일 먼저 실행&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 위의 코드를 실행하게 될 경우 가장 아래에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log('내가 제일 먼저 실행');&lt;/code&gt;이 먼저 실행되게 되는데 이는 Node js의 논블로킹 I/O 특성 때문이다.&lt;/p&gt;

&lt;p&gt;만약, 가장 아래에 있는 console.log까지 순차적으로 실행되기를 원한다면 다음과 같이 코드를 작성할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;updatedUser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updateUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updatedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;deletedUser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;deleteUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;updatedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;deletedUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;내가 제일 먼저 실행&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
  	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;async와 await 키워드를 사용하게 되면 코드들이 깔끔하게 표현되는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;다만, 에러를 잡기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try-catch&lt;/code&gt; 문을 사용해야 된다.&lt;/p&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><category term="Study" /><category term="Study" /><category term="정리" /><summary type="html">promise, async, await 사용 방법</summary></entry><entry><title type="html">1d1c_1</title><link href="http://localhost:4000/1d1c_1/" rel="alternate" type="text/html" title="1d1c_1" /><published>2020-06-07T00:00:00+09:00</published><updated>2020-06-07T00:00:00+09:00</updated><id>http://localhost:4000/1d1c_1</id><content type="html" xml:base="http://localhost:4000/1d1c_1/">&lt;h2 id=&quot;0601&quot;&gt;06.01&lt;/h2&gt;

&lt;p&gt;오늘은 자바 8 인 액션이라는 책을 공부했다.&lt;/p&gt;

&lt;p&gt;기존의 코드를 보면서 Stream과 Optional처럼 모르는 문법을 몰라서 책을 사서 공부하였다.&lt;/p&gt;

&lt;h3 id=&quot;커밋-로그&quot;&gt;커밋 로그&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/anstjaos/anstjaos.github.io/commit/d5061ebf459775f225229963217851fcdc1d3ea8&quot;&gt;Set theme jekyll-theme-midnight&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/anstjaos/anstjaos.github.io/commit/19632c9f271b5ac782a5abeae636c31e737d5264&quot;&gt;Modify 1Day 1Commit post&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/anstjaos/anstjaos.github.io/commit/5ad73d5bcc817c534d15b156736ccc9022dd9bce&quot;&gt;Merge branch ‘master’ of&lt;/a&gt; https://github.com/anstjaos/anstjaos.github.io&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/anstjaos/anstjaos.github.io/commit/3ae3a47fd6f1480080da0535ac7696e9c10ce278&quot;&gt;Updload 1Day 1Commit post&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><summary type="html">06.01</summary></entry><entry><title type="html">[Object] 10장</title><link href="http://localhost:4000/study/object-chapter10/" rel="alternate" type="text/html" title="[Object] 10장" /><published>2020-06-04T00:00:00+09:00</published><updated>2020-06-04T00:00:00+09:00</updated><id>http://localhost:4000/study/object-chapter10</id><content type="html" xml:base="http://localhost:4000/study/object-chapter10/">&lt;h1 id=&quot;10-상속과-코드-재사용&quot;&gt;10. 상속과 코드 재사용&lt;/h1&gt;

&lt;p&gt;재사용 관점에서 &lt;b&gt;상속&lt;/b&gt;이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법이다. 객체지향에서는 상속 외에도 코드를 효과적으로 재사용할 수 있는 방법이 한 가지 더 있다. 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법으로 흔히 &lt;b&gt;합성&lt;/b&gt;이라고 부른다.&lt;/p&gt;

&lt;h2 id=&quot;상속과-중복-코드&quot;&gt;상속과 중복 코드&lt;/h2&gt;

&lt;h3 id=&quot;dry-원칙&quot;&gt;DRY 원칙&lt;/h3&gt;

&lt;p&gt;중복 코드는 변경을 방해한다. 프로그램의 본질은 비즈니스와 관련된 지식을 코드로 변환하는 것이다. 그에 맞춰 지식을 표현하는 코드 역시 변경해야 한다.&lt;/p&gt;

&lt;p&gt;중복 코드가 가지는 가장 큰 문제는 &lt;b&gt;코드를 수정하는 데 필요한 노력을 몇 배로 증가&lt;/b&gt;시킨다는 것이다.
중복 여부를 판단하는 기준은 변경이다. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다.&lt;/p&gt;

&lt;p&gt;신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만드는 효과적인 방법 중 하나는 &lt;b&gt;중복을 제거&lt;/b&gt;하는 것이다. 프로그래머들은 &lt;b&gt;DRY 원칙&lt;/b&gt;을 따라야 한다. DRY는 ‘반복하지 마라’라는 뜻의 &lt;b&gt;Don’t Repeat Yourself&lt;/b&gt;의 첫 글자를 모아 마든 용어로 간단히 말해 동일한 지식을 중복하지 말라는 것이다.&lt;/p&gt;

&lt;p&gt;DRY 원칙은 &lt;b&gt;한 번, 단 한번(Once and Only Once) 원칙&lt;/b&gt; 또는 &lt;b&gt;단일 지점 제어(Single-Point Control) 원칙&lt;/b&gt;이라고도 부른다.&lt;/p&gt;

&lt;h3 id=&quot;중복과-변경&quot;&gt;중복과 변경&lt;/h3&gt;

&lt;h4 id=&quot;중복코드-살펴보기&quot;&gt;중복코드 살펴보기&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Phone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Phone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;seconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ZERO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;call:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;                                                                 &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NightlyDiscountPhone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;LATE_NIGHT_HOUR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nightlyAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regularAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NightlyDiscountPhone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nightlyAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regularAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nightlyAmount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nightlyAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;regularAmount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regularAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;seconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ZERO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getForm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHour&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;LATE_NIGHT_HOUR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;nightlyAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;                                                                       &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;regularAmout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
                                                              &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;중복-코드-수정하기&quot;&gt;중복 코드 수정하기&lt;/h4&gt;

&lt;p&gt;현재 통화 요금을 계산하는 로직은 Phone과 NightlyDiscountPhone 양쪽 모두에 구현돼있기 때문에 세금을 추가하기 위해서는 두 클래스를 함께 수정해야 한다.&lt;/p&gt;

&lt;p&gt;많은 코드 더미 속에서 어떤 코드가 중복인지를 파악하는 일은 쉬운 일이 아니다. 중복 코드는 항상 함께 수정돼야 하기 때문에 수정할 때 하나라도 빠트린다면 버그로 이어질 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;중복 코드는 새로운 중복 코드를 부른다.&lt;/b&gt; 더 큰 문제는 중복 코드가 늘어날 수록 애플리케이션은 변경에 취약해지고 버그가 발생할 가능성이 높아진다는 것이다.&lt;/p&gt;

&lt;h4 id=&quot;타입-코드-사용하기&quot;&gt;타입 코드 사용하기&lt;/h4&gt;

&lt;p&gt;두 클래스 사이의 중복 코드를 제거하는 한 가지 방법은 &lt;b&gt;클래스를 하나로 합치는 것&lt;/b&gt;이다. 타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도라는 문제에 시달리게 된다.&lt;/p&gt;

&lt;h3 id=&quot;상속을-이용해서-중복-코드-제거하기&quot;&gt;상속을 이용해서 중복 코드 제거하기&lt;/h3&gt;

&lt;p&gt;상속의 기본 아이디어는 이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 상속을 이용해 코드를 재사용하라는 것이다.&lt;/p&gt;

&lt;p&gt;상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 생각처럼 쉽지 않다. 요구사항과 구현 사이의 차이가 크면 클수록 코드를 이해하기 어려워진다. 잘못 사용된 상속은 이 차이를 더 크게 벌린다.&lt;/p&gt;

&lt;p&gt;상속을 이용해 코드를 재사용하기 위해서는 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다. 이것은 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;따라서 상속은 결합도를 높인다.&lt;/b&gt;&lt;/p&gt;

&lt;h3 id=&quot;강하게-결합된-phone과-nightlydiscountphone&quot;&gt;강하게 결합된 Phone과 NightlyDiscountPhone&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NightlyDiscountPhone&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Phone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NightlyDiscountPhone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nightlyAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regularAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt;                  &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taxRate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regularAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taxRate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;minus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nightlyFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nightlyFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getTaxRate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;b&gt;상속을 위한 경고 1&lt;/b&gt;
자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이처럼 상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 &lt;b&gt;취약한 기반 클래스 문제&lt;/b&gt;라고 부른다.&lt;/p&gt;

&lt;h2 id=&quot;취약한-기반-클래스-문제&quot;&gt;취약한 기반 클래스 문제&lt;/h2&gt;

&lt;p&gt;강한 결합도로 인해 자식 클래스는 부모 클래스의 불필요한 세부사항에 엮이게 된다. 부모 클래스의 작은 변경에도 자식 클래스는 컴파일 오류와 실행 에러라는 고통에 시달려야 할 수도 있다.&lt;/p&gt;

&lt;p&gt;이처럼 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 &lt;b&gt;취약한 기반 클래스 문제(Fragile Base Class Problem, Brittle Base Class Problem)&lt;/b&gt;이라고 부른다.&lt;/p&gt;

&lt;p&gt;취약한 기반 클래스 문제는 상속이라는 문맥 안에서 &lt;b&gt;결합도가 초래하는 문제점&lt;/b&gt;을 가리키는 용어다. 상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다는 사실을 알고 있어야 한다. 상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는 데는 용이하지만 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다.&lt;/p&gt;

&lt;p&gt;상속은 자식 클래스가 부모의 &lt;b&gt;구현 세부사항에 의존&lt;/b&gt;하도록 만들기 때문에 캡슐화를 약화시킨다. 상속을 사용하면 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 자식 클래스가 영향을 받기 쉬워진다.&lt;/p&gt;

&lt;p&gt;객체지향의 기반은 &lt;b&gt;캡슐화를 통한 변경의 통제&lt;/b&gt;다. 상속은 코드의 재사용을 위해 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킨다.&lt;/p&gt;

&lt;h3 id=&quot;불필요한-인터페이스-상속-문제&quot;&gt;불필요한 인터페이스 상속 문제&lt;/h3&gt;

&lt;p&gt;상속을 잘못 사용한 대표적인 사례는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.Stack&lt;/code&gt;이다. 부모 클래스의 상속받은 메서드를 사용할 경우 자식 클래스의 규칙이 위반될 수 있다.&lt;/p&gt;

&lt;p&gt;Stack은 가장 나중에 추가된 요소가 가장 먼저 추출되는(Last In First Out, LIFO) 자료구조인 스택을 구현한 클래스다. Vector는 임의의 위치에서 요소를 추출하고 삽입할 수 있는 리스트 자료 구조의 구현체로서 java.util.List의 초기 버전이라고 할 수 있다. Vector를 재사용하기 위해 Stack을 Vector의 자식 클래스로 구현했다.&lt;/p&gt;

&lt;p&gt;안타깝게도 Stack이 Vector를 상속받기 때문에 Stack의 퍼블릭 인터페이스에 Vector의 퍼블릭 인터페이스가 합쳐진다. 따라서 Stack에게 상속된 Vector의 퍼블릭 인터페이스를 이용하면 &lt;b&gt;임의의 위치에서 요소를 추가하거나 삭제&lt;/b&gt;할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1st&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2nd&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3rd&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;4th&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;assertEquals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;4th&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 에러!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문제의 원인은 Stack이 규칙을 무너뜨릴 여지가 있는 위험한 Vector의 퍼블릭 인터페이스까지도 함께 상속받았기 때문이다. &lt;b&gt;인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 만들어야 한다.&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;객체지향의 핵심은 객체들의 협력이다. 단순히 코드를 재사용하기 위해 &lt;b&gt;불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안된다.&lt;/b&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;b&gt;상속을 위한 경고 2&lt;/b&gt;
상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;메서드-오버라이딩의-오작용-문제&quot;&gt;메서드 오버라이딩의 오작용 문제&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InstrumentedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;addCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;addCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;InstrumentedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;languages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InstrumentedHashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;languages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;java&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Ruby&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Scala&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 실행한 후에 addCount의 값이 3이 될 거라고 예상할 것이다. 하지만 실제로 실행한 후의 addCount의 값은 6이다. 그 이유는 부모 클래스인 HashSet의 addAll 메서드 안에서 add 메서드를 호출하기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;b&gt;상속을 위한 경고 3&lt;/b&gt;
자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;조슈아 블로치는 클래스가 상속되기를 원한다면 상속을 위해 &lt;b&gt;클래스를 설계하고 문서화&lt;/b&gt;해야 하며, 그렇지 않은 경우에는 상속을 금지시켜야 한다고 주장한다.&lt;/p&gt;

&lt;p&gt;설계는 &lt;b&gt;트레이드오프 활동&lt;/b&gt;이라는 사실을 기억하라. 상속은 코드 재사용을 위해 캡슐화를 희생한다.&lt;/p&gt;

&lt;h3 id=&quot;부모-클래스와-자식-클래스의-동시-수정-문제&quot;&gt;부모 클래스와 자식 클래스의 동시 수정 문제&lt;/h3&gt;

&lt;p&gt;상속을 사용하면 자식 클래스가 부모 클래스의 구현에 강하게 결합되기 때문에 이 문제를 피하기는 어렵다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;결합도&lt;/b&gt;란 다른 대상에 대해 알고 있는 지식의 양이다. 상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 대해 속속들이 알도록 강요한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;b&gt;상속을 위한 경고 4&lt;/b&gt;
클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;phone-다시-살펴보기&quot;&gt;Phone 다시 살펴보기&lt;/h2&gt;

&lt;h3 id=&quot;추상화에-의존하자&quot;&gt;추상화에 의존하자&lt;/h3&gt;

&lt;p&gt;NightlyDiscountPhone의 가장 큰 문제점은 Phone에 강하게 결합돼 있기 때문에 Phone이 변경될 경우 함께 변경될 가능성이 높다는 것이다. 이 문제를 해결하는 가장 일반적인 방법은 자식 클래스가 부모 클래스의 구현이 아닌 &lt;b&gt;추상화에 의존&lt;/b&gt;하도록 만드는 것이다. 정확하게 말하면 &lt;b&gt;부모 클래스와 자식 클래스 모두 추상화에 의존&lt;/b&gt;하도록 수정해야 한다.&lt;/p&gt;

&lt;p&gt;코드 중복을 제거하기 위해 상속을 도입할 때 따르는 두 가지 원칙이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 메서드가 유사하게 보인다면 &lt;b&gt;차이점을 메서드로 추출&lt;/b&gt;하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;부모 클래스의 코드를 하위로 내리지 말고 &lt;b&gt;자식 클래스의 코드를 상위로 올려라.&lt;/b&gt; 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 &lt;b&gt;재사용성과 응집도 측면&lt;/b&gt;에서 더 뛰어난 결과를 얻을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;차이로-메서드를-추출하라&quot;&gt;차이로 메서드를 추출하라&lt;/h3&gt;

&lt;p&gt;가장 먼저 할 일은 &lt;b&gt;중복 코드 안에서 차이점을 별도의 메서드로 추출&lt;/b&gt;하는 것이다. 이것은 흔히 말하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;변하는 것으로부터 변하지 않는 것을 분리하라.&quot;&lt;/code&gt;, 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;변하는 부분을 찾고 이를 캡슐화하라&quot;&lt;/code&gt; 라는 조언을 메서드 수준에서 적용한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
먼저 Phone에서 메서드를 추출하자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Phone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ZERO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;calculateCallFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateCallFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NightlyDiscountPhone의 경우에도 동일한 방식으로 메서드를 추출하자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NightlyDiscountPhone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ZERO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;calculateCallFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateCallFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getHour&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;LATE_NIGHT_HOUR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nightlyAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
                                                            &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regularAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDuration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
                                                            &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSeconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 같은 코드를 부모 클래스로 올리는 일만 남았다.&lt;/p&gt;

&lt;h3 id=&quot;중복-코드를-부모-클래스로-올려라&quot;&gt;중복 코드를 부모 클래스로 올려라&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractPhone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Phone&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractPhone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NightlyDiscountPhone&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractPhone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 Phone과 NightlyDiscountPhone의 공통 부분을 부모 클래스로 이동시키자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractPhone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ZERO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;calculateCallFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateCallFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/83730829-98f04b00-a684-11ea-844e-c5e52f0574cc.png&quot; alt=&quot;10.1.png&quot; /&gt;&lt;br /&gt;
&lt;i&gt;&lt;b&gt;그림 10.1&lt;/b&gt; 리팩터링 후의 상속 계층&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;자식 클래스들 사이의 공통점을 부모 클래스로 옮김으로써 실제 코드를 기반으로 상속 계층을 구성할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;추상화가-핵심이다&quot;&gt;추상화가 핵심이다.&lt;/h3&gt;

&lt;p&gt;지금까지 살펴본 모든 장점은 클래스들이 추상화에 의존하기 때문에 얻어지는 장점이다. 상속 계층이 코드를 진화시키는 데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩터링하라.&lt;/p&gt;

&lt;h3 id=&quot;의도를-드러내는-이름-선택하기&quot;&gt;의도를 드러내는 이름 선택하기&lt;/h3&gt;

&lt;p&gt;기존의 세 클래스들의 이름은 애매모호함이 있다. 따라서 다음과 같이 이름을 변경하는 것이 적절할 것이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Phone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RegularPhone&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Phone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NightlyDiscountPhone&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Phone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;세금-추가하기&quot;&gt;세금 추가하기&lt;/h3&gt;

&lt;p&gt;클래스 사이의 상속은 자식 클래스가 부모 클래스가 구현한 행동뿐만 아니라 &lt;b&gt;인스턴스 변수&lt;/b&gt;에 대해서도 결합되게 만든다.&lt;/p&gt;

&lt;p&gt;인스턴스 변수의 목록이 변하지 않는 상황에서 &lt;b&gt;객체의 행동만 변경&lt;/b&gt;된다면 상속 계층에 속한 각 클래스들을 독립적으로 진화시킬 수 있다. 결과적으로 책임을 아무리 잘 분배하더라도 &lt;b&gt;인스턴스 변수의 추가&lt;/b&gt;는 종종 상속 계층 전반에 걸친 변경을 유발한다.&lt;/p&gt;

&lt;p&gt;상속으로 인한 클래스 사이의 결합을 피할 수 있는 방법은 없다. 우리가 원하는 것은 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 상속 계층 전체에 걸쳐 부작용이 퍼지지 않게 막는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;차이에-의한-프로그래밍&quot;&gt;차이에 의한 프로그래밍&lt;/h2&gt;

&lt;p&gt;기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 &lt;b&gt;차이에 의한 프로그래밍(programming by difference)&lt;/b&gt;이라고 부른다. 상속을 이용하면 이미 존재하는 클래스의 코드를 쉽게 재사용할 수 있기 때문에 애플리케이션의 점진적인 정의가 가능해진다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;차이에 의한 프로그래밍의 목표&lt;/b&gt;는 중복 코드를 제거하고 코드를 재사용하는 것이다. &lt;b&gt;중복을 제거&lt;/b&gt;하기 위해서는 코드를 재사용 가능한 단위로 분해하고 재구성해야 한다. &lt;b&gt;코드를 재사용&lt;/b&gt;하기 위해서는 중복 코드를 제거해서 하나의 모듈로 모아야 한다. 따라서 중복 코드를 제거하기 위해 최대한 코드를 재사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;재사용 가능한 코드&lt;/b&gt;란 심각한 버그가 존재하지 않는 코드다. 따라서 코드를 재사용하면 코드의 품질은 유지하면서도 코드를 작성하는 노력과 테스트는 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;상속이 코드 재사용이라는 측면에서 매우 강력한 도구인 것은 사실이지만 강력한 만큼 잘못 사용할 경우에 돌아오는 피해 역시 크다는 사실을 알아야 한다.&lt;/p&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><category term="Study" /><category term="Object" /><category term="OOP" /><category term="UML" /><category term="Study" /><category term="요약" /><category term="정리" /><summary type="html">Object 10장 요약</summary></entry><entry><title type="html">[Object] 9장</title><link href="http://localhost:4000/study/object-chapter9/" rel="alternate" type="text/html" title="[Object] 9장" /><published>2020-06-04T00:00:00+09:00</published><updated>2020-06-04T00:00:00+09:00</updated><id>http://localhost:4000/study/object-chapter9</id><content type="html" xml:base="http://localhost:4000/study/object-chapter9/">&lt;h1 id=&quot;9-유연한-설계&quot;&gt;9. 유연한 설계&lt;/h1&gt;

&lt;h2 id=&quot;개방-폐쇄-원칙&quot;&gt;개방-폐쇄 원칙&lt;/h2&gt;

&lt;p&gt;로버트 마틴은 확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙 중 하나로 &lt;b&gt;개방-폐쇄 원칙(Open-Closed Principle, OCP)&lt;/b&gt;을 고안했다. 개방-폐쇄 원칙은 다음과 같은 문장으로 요약할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기서 키워드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;확장&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수정&lt;/code&gt;이다. 이 둘은 순서대로 애플리케이션의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동작&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;코드&lt;/code&gt;의 관점을 반영한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;확장&lt;/b&gt;에 열려 있다: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 ‘동작’을 추가해서 애플리케이션의 기능을 확장할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;수정&lt;/b&gt;에 대해 닫혀 있다: 기존의 ‘코드’를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;개방-폐쇄 원칙은 &lt;b&gt;유연한 설계&lt;/b&gt;란 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계라고 이야기한다.&lt;/p&gt;

&lt;h3 id=&quot;컴파일타임-의존성을-고정시키고-런타임-의존성을-변경하라&quot;&gt;컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라&lt;/h3&gt;

&lt;p&gt;사실 개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다.
&lt;b&gt;런타임 의존성&lt;/b&gt;은 실행 시에 협력에 참여하는 객체들 사이의 관계다.
&lt;b&gt;컴파일타임 의존성&lt;/b&gt;은 코드에서 드러나는 클래스들 사이의 관계다.
컴파일타임 의존성과 런타임 의존성은 동일하지 않다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/83730246-c1c41080-a683-11ea-873a-8318a348e034.png&quot; alt=&quot;9.1.png&quot; /&gt;&lt;br /&gt;
&lt;i&gt;&lt;b&gt;그림 9.1&lt;/b&gt; 할인 정책에서의 컴파일타임 의존성과 런타임 의존성의 차이&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;현재의 설계는 새로운 할인 정책을 추가해서 기능을 확장할 수 있도록 허용한다. 따라서 &lt;b&gt;‘확장에 대해서는 열려 있다.’&lt;/b&gt;
현재의 설계는 기존 코드를 수정할 필요 없이 새로운 클래스를 추가하는 것만으로 새로운 할인 정책을 확장할 수 있다. 따라서 &lt;b&gt;‘수정에 대해서는 닫혀 있다.’&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;의존성 관점&lt;/b&gt;에서 개방-폐쇄 원칙을 따르는 설계란 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조라고 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;추상화가-핵심이다&quot;&gt;추상화가 핵심이다&lt;/h3&gt;

&lt;p&gt;개방-폐쇄 원칙의 핵심은 &lt;b&gt;추상화에 의존하는 것&lt;/b&gt;이다. 추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다.&lt;/p&gt;

&lt;p&gt;개방-폐쇄 원칙의 관점에서 &lt;b&gt;생략되지 않고 남겨지는 부분&lt;/b&gt;은 다양한 상황에서의 공통점을 반영한 추상화의 결과물이다. 공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다. 따라서 추상화 부분은 &lt;b&gt;수정에 대해 닫혀 있다.&lt;/b&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountCondition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conditions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateDiscountAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountCondition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conditions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isSatisfiedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDiscountAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMovieFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getDiscountAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 변하지 않는 부분은 할인 여부를 판단하는 로직이고 변하는 부분은 할인된 요금을 계산하는 방법이다. 따라서 DiscountPolicy는 추상화다. 추상화 과정을 통해 생략된 부분은 할인 요금을 계산하는 방법이다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;명시적 의존성&lt;/b&gt;과 &lt;b&gt;의존성 해결 방법&lt;/b&gt;을 통해 컴파일타임 의존성을 런타임 의존성으로 대체함으로써 실행 시에 객체의 행동을 확장할 수 있다. 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.&lt;/p&gt;

&lt;p&gt;주의할 점은 추상화를 했다고 해서 &lt;b&gt;모든 수정에 대해 설계가 폐쇄되는 것은 아니라&lt;/b&gt;는 것이다. &lt;b&gt;변경에 의한 파급효과&lt;/b&gt;를 최대한 피하기 위해서는 &lt;b&gt;변하는 것과 변하지 않는 것&lt;/b&gt;이 무엇인지를 이해하고 이를 &lt;b&gt;추상화의 목적&lt;/b&gt;으로 삼아야만 한다.&lt;/p&gt;

&lt;h2 id=&quot;생성-사용-분리&quot;&gt;생성 사용 분리&lt;/h2&gt;

&lt;p&gt;Movie가 오직 DiscountPolicy라는 추상화에만 의존하기 위해서는 구체 클래스의 인스턴스를 생성해서는 안 된다. 이것은 동작을 추가하거나 변경하기 위해 기존의 코드를 수정하도록 만들기 때문에 개방-폐쇄 원칙을 위반한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runningTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPoilicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다. 알아야 하는 지식이 많으면 결합도도 높아진다. &lt;b&gt;객체의 타입과 생성자에 전달해야 하는 인자에 대한 과도한 지식&lt;/b&gt;은 코드를 특정한 컨텍스트에 강하게 결합시킨다.&lt;/p&gt;

&lt;p&gt;동일한 클래스 안에서 &lt;b&gt;객체 생성과 사용&lt;/b&gt;이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것이 문제다.&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/83730334-e02a0c00-a683-11ea-872f-174c665a40cb.png&quot; alt=&quot;9.2.png&quot; /&gt;&lt;br /&gt;
&lt;i&gt;&lt;b&gt;그림 9.2&lt;/b&gt; 생성과 사용의 책임을 함께 맡고 있는 Movie&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;객체에 대한 &lt;b&gt;생성과 사용을 분리(separating use from creation)&lt;/b&gt;해야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 “연결”하는) 시작 단계와 (시작 단계 이후에 이어지는) 실행 단계를 분리해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 &lt;b&gt;객체를 생성할 책임을 클라이언트로 옮기는 것&lt;/b&gt;이다. 현재의 컨텍스트에 관한 결정권을 가지고 있는 클라이언트로 컨텍스트에 대한 지식을 옮김으로써 Movie는 특정한 클라이언트에 결합되지 않고 독립적일 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getAvatarFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;아바타&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                                 &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofMinutes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                                 &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                                 &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그림 9.2에서 Movie는 AmountDiscountPolicy에 대한 의존성 때문에 금액 할인 정책이라는 구체적인 컨텍스트에 묶여 있다. 반면 그림 9.3에서는 인스턴스를 생성하는 책임을 클라이언트에게 맡김으로써 Movie는 오직 DiscountPolicy의 인스턴스를 사용하는 데만 주력하고 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/83730380-f33cdc00-a683-11ea-9a1f-0f9c8a365736.png&quot; alt=&quot;9.3.png&quot; /&gt;&lt;br /&gt;
&lt;i&gt;&lt;b&gt;그림 9.3&lt;/b&gt; Client에게 생성을 위임하고 Movie는 DiscountPolicy의 사용에만 집중한다&lt;/i&gt;&lt;/p&gt;

&lt;h3 id=&quot;factory-추가하기&quot;&gt;FACTORY 추가하기&lt;/h3&gt;

&lt;p&gt;Movie를 사용하는 Client도 특정한 컨텍스트에 묶이지 않기를 바란다고 가정해보자.&lt;/p&gt;

&lt;p&gt;Client 역시 생성과 사용의 책임을 함께 지니고 있다. 이 경우 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 Client는 이 객체를 사용하도록 만들 수 있다. 이처럼 생성과 사용을 분리하기 위해 &lt;b&gt;객체 생성&lt;/b&gt;에 특화된 객체를 &lt;b&gt;FACTORY&lt;/b&gt;라고 부른다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Factory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createAvatarMovie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;아바타&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                         &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofMinutes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                         &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                         &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FACTORY를 사용하면 Movie와 AmountDiscountPolicy를 생성하는 책임 모두를 FACTORY로 이동할 수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/83730416-02238e80-a684-11ea-9739-ecb8d0934615.png&quot; alt=&quot;9.4.png&quot; /&gt;&lt;br /&gt;
&lt;i&gt;&lt;b&gt;그림 9.4&lt;/b&gt; 객체 생성을 전담하는 FACTORY를 추가한 후의 의존성&lt;/i&gt;&lt;/p&gt;

&lt;h3 id=&quot;순수한-가공물에게-책임-할당하기&quot;&gt;순수한 가공물에게 책임 할당하기&lt;/h3&gt;

&lt;p&gt;책임 할당의 가장 기본이 되는 원칙은 책임을 수행하는 데 필요한 정보를 가장 많이 알고 있는 &lt;b&gt;INFORMATION EXPERT&lt;/b&gt;에게 책임을 할당하는 것이다.&lt;/p&gt;

&lt;p&gt;FACTORY는 도메인 모델에 속하지 않는다. FACTORY를 추가한 이유는 순수하게 기술적인 결정이다. 전체적으로 &lt;b&gt;결합도를 낮추고 재사용성을 높이기 위해&lt;/b&gt; 도메인 개념에게 할당돼 있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것이다.&lt;/p&gt;

&lt;p&gt;크레이그 라만은 시스템을 객체로 분해하는 데는 크게 두 가지 방식이 존재한다고 설명한다. 하나는 &lt;b&gt;표현적 분해(representational decomposition)&lt;/b&gt;이고 다른 하나는 &lt;b&gt;행위적 분해(behavioral decomposition)&lt;/b&gt;다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;표현적 분해&lt;/b&gt;는 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것이다. 표현적 분해는 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 &lt;b&gt;표현적 차이를 최소화&lt;/b&gt;하는 것을 목적으로 한다.&lt;/p&gt;

&lt;p&gt;그러나 종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생한다. 도메인 모델은 설계를 위한 중요한 출발점이지만 &lt;b&gt;단지 출발점&lt;/b&gt;이라는 사실을 명심해야 한다.&lt;/p&gt;

&lt;p&gt;모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제점에 봉착하게 될 가능성이 높아진다. 크레이그 라만은 이처럼 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 &lt;b&gt;PURE FABRICATION(순수한 가공물)&lt;/b&gt;이라고 부른다.&lt;/p&gt;

&lt;p&gt;어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 &lt;b&gt;PURE FABRICATION&lt;/b&gt;을 추가하고 이 객체에게 책임을 할당하라.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
이런 측면에서 객체지향이 실세계의 모방이라는 말은 옳지 않다. 애플리케이션 내에서 인공적으로 창조한 객체들이 도메인 개념을 반영하는 객체들보다 오히려 더 많은 비중을 차지하는 것이 일반적이다.&lt;/p&gt;

&lt;p&gt;설계자로서의 우리의 역할은 &lt;b&gt;도메인 추상화&lt;/b&gt;를 기반으로 애플리케이션 로직을 설계하는 동시에 &lt;b&gt;품질의 측면&lt;/b&gt;에서 균형을 맞추는 데 필요한 객체들을 창조하는 것이다. 도메인 개념을 표현하는 객체와 순수하게 창조된 가공의 객체들이 모여 자신의 역할과 책임을 다하고 조화롭게 협력하는 애플리케이션을 설계하는 것이 목표여야 한다.&lt;/p&gt;

&lt;h2 id=&quot;의존성-주입&quot;&gt;의존성 주입&lt;/h2&gt;

&lt;p&gt;외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 &lt;b&gt;의존성 주입(Dependency Injection)&lt;/b&gt;이라고 부른다. 이 기법을 의존성 주입이라고 부르는 이유는 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;의존성 해결&lt;/b&gt;은 컴파일타임 의존성과 런타임 의존성의 차이점을 해소하기 위한 다양한 매커니즘을 포괄한다.
&lt;b&gt;의존성 주입&lt;/b&gt;은 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록 만드는 방법을 포괄하는 명칭이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;b&gt;생성자 주입(constructor injection):&lt;/b&gt; 객체를 생성하는 시점에 생성자를 통한 의존성 해결&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;setter 주입(setter injection):&lt;/b&gt; 객체 생성 후 setter 메서드를 통한 의존성 해결&lt;/li&gt;
  &lt;li&gt;&lt;b&gt;메서드 주입(method injection):&lt;/b&gt; 메서드 실행 시 인자를 이용한 의존성 해결&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;생성자 주입&lt;/b&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;아바타&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                         &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofMinutes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                         &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                         &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;setter 주입&lt;/b&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;setter 주입의 단점은 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지를 명시적으로 표현할 수 없다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;메서드 주입&lt;/b&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;calculateDiscountAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;메서드 주입은 &lt;b&gt;메서드 호출 주입(method call injection)&lt;/b&gt;이라고도 부르며 메서드가 의존성을 필요로 하는 유일한 경우일 때 사용할 수 있다. &lt;b&gt;생성자 주입&lt;/b&gt;을 통해 의존성을 전달받으면 객체가 올바른 상태로 생성되는데 필요한 &lt;b&gt;의존성을 명확하게 표현할 수 있다는 장점&lt;/b&gt;이 있지만 주입된 의존성이 한 두 개의 메서드에서만 사용된다면 각 &lt;b&gt;메서드의 인자&lt;/b&gt;로 전달하는 것이 더 나은 방법일 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;숨겨진-의존성은-나쁘다&quot;&gt;숨겨진 의존성은 나쁘다&lt;/h3&gt;

&lt;p&gt;&lt;b&gt;SERVICE LOCATOR&lt;/b&gt;는 의존성을 해결할 객체들을 보관하는 일종의 저장소다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지(서비스를 구현한 구체 클래스의 타입이 무엇인지), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runningTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;runningTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runningTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fee&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServiceLocator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServiceLocator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServiceLocator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;soleInstance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServiceLocator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;soleInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;soleInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ServiceLocator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Movie의 인스턴스가 AmountDiscountPolicy의 인스턴스에 의존하기를 원한다면 다음과 같이 정의하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ServiceLocator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;provide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;아바타&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                         &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofMinutes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
                         &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;b&gt;SERVICE LOCATOR&lt;/b&gt; 패턴의 가장 큰 단점은 의존성을 감춘다는 것이다. 의존성은 암시적이며 코드 깊숙한 곳에 숨겨져 있다.&lt;/p&gt;

&lt;p&gt;의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 컴파일타임이 아닌 &lt;b&gt;런타임&lt;/b&gt;에 가서야 발견된다는 사실을 알 수 있다. &lt;b&gt;숨겨진 의존성&lt;/b&gt;이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 때문이다.&lt;/p&gt;

&lt;p&gt;의존성을 숨기는 코드는 &lt;b&gt;단위 테스트 작성도 어렵다.&lt;/b&gt; 각 단위 테스트는 서로 고립돼야 한다는 단위 테스트의 기본 원칙을 위반한다.&lt;/p&gt;

&lt;p&gt;캡슐화는 코드를 읽고 이해하는 행위와 관련이 있다. 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드다. 숨겨진 의존성이 가지는 가장 큰 문제점은 의존성을 이해하기 위해 &lt;b&gt;코드의 내부 구현을 이해할 것을 강요한다&lt;/b&gt;는 것이다. 따라서 &lt;b&gt;숨겨진 의존성은 캡슐화를 위반&lt;/b&gt;한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어트려 놓는다. 가급적 의존성을 퍼블릭 인터페이스에 노출하라. 의존성을 구현 내부에 숨기면 숨길수록 코드를 이해하기도, 수정하기도 어려워진다.&lt;/p&gt;

&lt;h2 id=&quot;의존성-역전-원칙&quot;&gt;의존성 역전 원칙&lt;/h2&gt;

&lt;h3 id=&quot;추상화와-의존성-역전&quot;&gt;추상화와 의존성 역전&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 설계가 변경에 취약한 이유는 요금을 계한하는 상위 정책이 요금을 계산하는데 필요한 &lt;b&gt;구체적인 방법에 의존&lt;/b&gt;하기 때문이다.&lt;/p&gt;

&lt;p&gt;객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 &lt;b&gt;상위 수준의 정책&lt;/b&gt;이다. 다시 말해서 어떤 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스다.&lt;/p&gt;

&lt;p&gt;의존성은 변경의 전파와 관련된 것이기 때문에 설계는 &lt;b&gt;변경의 영향을 최소화&lt;/b&gt;하도록 의존성을 관리해야 한다. 대부분의 경우 우리가 재사용하려는 대상은 상위 수준의 클래스라는 점을 기억하라. 상위 수준의 클래스가 하위 수준의 클래스에 의존하면 상위 수준의 클래스를 재사용할 때 하위 수준의 클래스도 필요하기 때문에 재사용하기가 어려워진다.&lt;/p&gt;

&lt;p&gt;이 경우에도 해결사는 &lt;b&gt;추상화&lt;/b&gt;다. Movie와 AmountDiscountPolicy 모두가 &lt;b&gt;추상화에 의존&lt;/b&gt;하도록 수정하면 하위 수준 클래스의 변경으로 인해 상위 수준의 클래스가 영향을 받는 것을 방지할 수 있다. 또한 상위 수준을 재사용할 때 하위 수준의 클래스에 얽매이지 않고도 &lt;b&gt;다양한 컨텍스트에서 재사용이 가능&lt;/b&gt;하다.&lt;/p&gt;

&lt;p&gt;이제 지금까지 살펴본 내용들을 정리해보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.&lt;/li&gt;
  &lt;li&gt;추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이를 &lt;b&gt;의존성 역전 원칙(Dependency Inversion Principle, DIP)&lt;/b&gt;이라고 부른다.&lt;/p&gt;

&lt;h3 id=&quot;의존성-역전-원칙과-패키지&quot;&gt;의존성 역전 원칙과 패키지&lt;/h3&gt;

&lt;p&gt;객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈이다.
할인 정책과 관련된 패키지의 구조가 그림 9.5와 같다고 가정해 보자.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/83730483-1cf60300-a684-11ea-85fd-186d937ce247.png&quot; alt=&quot;9.5.png&quot; /&gt;&lt;br /&gt;
&lt;i&gt;&lt;b&gt;그림 9.5&lt;/b&gt; 인터페이스가 서버 모듈 쪽에 위치하는 전통적인 모듈 구조&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Movie를 다양한 컨텍스트에서 재사용하기 위해서는 불필요한 클래스들이 Movie와 함께 배포돼야만 한다.
코드의 컴파일이 성공하기 위해 함께 존재해야 하는 코드를 정의하는 것이 바로 컴파일타임 의존성이다. 불필요한 클래스들을 같은 패키지에 두는 것은 전체적인 빌드 시간을 가파르게 상승시킨다.&lt;/p&gt;

&lt;p&gt;따라서 그림 9.6과 같이 추상화를 별도의 독립적인 패키지가 아니라 &lt;b&gt;클라이언트가 속한 패키지&lt;/b&gt;에 포함시켜야 한다. 그리고 함께 재사용될 필요가 없는 클래스들을 별도의 독립적인 패키지에 모아야 한다. 마틴 파울러는 이 기법을 가리켜 &lt;b&gt;SEPARATED INTERFACE 패턴&lt;/b&gt;이라고 부른다.&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/83730525-2b441f00-a684-11ea-9837-55025c42b4ce.png&quot; alt=&quot;9.6.png&quot; /&gt;&lt;br /&gt;
&lt;i&gt;&lt;b&gt;그림 9.6&lt;/b&gt; 인터페이스의 소유권을 역전시킨 객체지향적인 모듈 구조&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Movie와 추상 클래스인 DiscountPolicy를 하나의 패키지로 모은 것은 Movie를 특정한 컨텍스트로부터 완벽하게 독립시킨다.&lt;/p&gt;

&lt;p&gt;의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 &lt;b&gt;인터페이스의 소유권&lt;/b&gt; 역시 역전시켜야 한다. 유연하고 재사용 가능하며 컨텍스트에 독립적인 설계는 전통적인 패러다임이 고수하는 의존성의 방향을 역전시킨다.&lt;/p&gt;

&lt;h2 id=&quot;유연성에-대한-조언&quot;&gt;유연성에 대한 조언&lt;/h2&gt;

&lt;h3 id=&quot;유연한-설계는-유연성이-필요할-때만-옳다&quot;&gt;유연한 설계는 유연성이 필요할 때만 옳다&lt;/h3&gt;

&lt;p&gt;&lt;b&gt;유연하고 재사용 가능한 설계&lt;/b&gt;란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일타임 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계를 의미한다. 하지만 유연하고 재사용 가능한 설계가 항상 좋은 것은 아니다.&lt;/p&gt;

&lt;p&gt;유연한 설계라는 말의 이면에는 &lt;b&gt;복잡한 설계&lt;/b&gt;라는 의미가 숨어 있다. &lt;b&gt;변경은 예상이 아니라 현실이어야 한다.&lt;/b&gt; 아직 일어나지 않은 변경은 변경이 아니다.&lt;/p&gt;

&lt;p&gt;설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다. 따라서 유연함은 단순성과 명확성의 희생 위에서 자라난다. &lt;b&gt;불필요한 유연성은 불필요한 복잡성을 낳는다.&lt;/b&gt; 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라.&lt;/p&gt;

&lt;h3 id=&quot;협력과-책임이-중요하다&quot;&gt;협력과 책임이 중요하다&lt;/h3&gt;

&lt;p&gt;설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야 한다. 중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선이다.&lt;/p&gt;

&lt;p&gt;의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다. 따라서 역할, 책임, 협력에 먼저 집중하라.&lt;/p&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><category term="Study" /><category term="Object" /><category term="OOP" /><category term="UML" /><category term="Study" /><category term="요약" /><category term="정리" /><summary type="html">Object 9장 요약</summary></entry><entry><title type="html">1 Day 1 Commit</title><link href="http://localhost:4000/1d1c/1day1commit/" rel="alternate" type="text/html" title="1 Day 1 Commit" /><published>2020-06-01T00:00:00+09:00</published><updated>2020-06-01T00:00:00+09:00</updated><id>http://localhost:4000/1d1c/1day1commit</id><content type="html" xml:base="http://localhost:4000/1d1c/1day1commit/">&lt;p&gt;회사 일 외에 별도로 코드 작업을 하지 않다보니 내 Github에 공백이 어마무시하게 생겼다…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/83364590-2c9fee00-a3dd-11ea-8111-828c6e079e84.png&quot; alt=&quot;git_blank&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이대론 안되겠다 싶어 여러가지를 보던 중 1일 1커밋(1 Day 1 Commit) 이라는 것을 보게 되었다.&lt;/p&gt;

&lt;p&gt;굉장히 좋은 것 같아 오늘부터(2020.06.01) 꾸준하게 커밋하려고 한다.&lt;/p&gt;

&lt;p&gt;단, 규칙이 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;무조건적인 커밋을 찍기 위한 어뷰징은 하지 않는다.&lt;/li&gt;
    &lt;li&gt;커밋 로그는 상세하게 쓰자.&lt;/li&gt;
    &lt;li&gt;다양한 것을 공부하자.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;1일 1커밋 운동을 하면서 간단하게 무엇을 했는지는 블로그에 기록하려고 한다.&lt;/p&gt;

&lt;p&gt;단, 주 단위로 기록하여 현재 글에 링크를 달아놓으려고 한다.&lt;/p&gt;

&lt;p&gt;얼마나 갈지는 모르겠지만 최대한 열심히 작성하자!&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;링크&quot;&gt;링크&lt;/h3&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><category term="1D1C" /><category term="1D1C" /><category term="Study" /><category term="개인공부" /><summary type="html">1일 1커밋 시작</summary></entry><entry><title type="html">[Object] 8장</title><link href="http://localhost:4000/study/object-chapter8/" rel="alternate" type="text/html" title="[Object] 8장" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/study/object-chapter8</id><content type="html" xml:base="http://localhost:4000/study/object-chapter8/">&lt;h1 id=&quot;8-의존성-관리하기&quot;&gt;8. 의존성 관리하기&lt;/h1&gt;

&lt;p&gt;잘 설계된 객체지향 애플리케이션은 &lt;strong&gt;작고 응집도 높은 객체&lt;/strong&gt;들로 구성된다. 작고 응집도 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘 하는 객체를 의미한다. 일반적인 애플리케이션의 기능을 구현하기 위해서는 다른 객체에게 도움을 요청해야 한다. 이런 요청이 객체 사이의 &lt;strong&gt;협력&lt;/strong&gt;을 낳는다.&lt;/p&gt;

&lt;p&gt;협력은 객체가 다른 객체에 대해 알 것을 강요한다. 이런 지식이 객체 사이의 의존성을 낳는다.&lt;/p&gt;

&lt;p&gt;협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다. 객체지향 설계의 핵심은 협력을 위해 &lt;strong&gt;필요한 의존성은 유지&lt;/strong&gt;하면서도 &lt;strong&gt;변경을 방해하는 의존성은 제거&lt;/strong&gt;하는데 있다. 이런 관점에서 객체지향 설계란 &lt;strong&gt;의존성을 관리&lt;/strong&gt;하는 것이고 객체가 변화를 받아들일 수 있게 &lt;strong&gt;의존성을 정리&lt;/strong&gt;하는 기술이라고 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;의존성-이해하기&quot;&gt;의존성 이해하기&lt;/h2&gt;

&lt;h3 id=&quot;변경과-의존성&quot;&gt;변경과 의존성&lt;/h3&gt;

&lt;p&gt;의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;실행 시점&lt;/strong&gt; : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구현 시점&lt;/strong&gt; : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 &lt;strong&gt;의존성이 존재&lt;/strong&gt;한다고 말한다. 두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다. 따라서 의존성은 &lt;strong&gt;변경에 의한 영향의 전파 가능성&lt;/strong&gt;을 암시한다.&lt;/p&gt;

&lt;h3 id=&quot;의존성-전이&quot;&gt;의존성 전이&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;의존성 전이(transitive dependency)&lt;/strong&gt; 가 의미하는 것은 PeriodCondition이 Screening에 의존할 경우 PeriodCondition은 Screening이 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것이다.
&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/82863278-ae66c600-9f5c-11ea-9f6a-29dd41cceba1.png&quot; alt=&quot;8.1.png&quot; /&gt;
&lt;i&gt;&lt;b&gt;그림 8.1&lt;/b&gt; 의존성 전이에 의해 잠재적으로 PeriodCondition은 Movie에 의존한다&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;의존성은 함께 변경될 수 있는 &lt;i&gt;가능성&lt;/i&gt;을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다. 의존성 전이는 변경에 의해 영향이 널리 전파될 수도 있다는 경고일 뿐이다.&lt;/p&gt;

&lt;p&gt;의존성은 전이될 수 있기 때문에 의존성의 종류를 &lt;strong&gt;직접 의존성(direct dependency)&lt;/strong&gt; 과 &lt;strong&gt;간접 의존성(indirect dependency)&lt;/strong&gt; 으로 나누기도 한다. &lt;strong&gt;직접 의존성&lt;/strong&gt;이란 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 가리킨다. &lt;strong&gt;간접 의존성&lt;/strong&gt;이란 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다.&lt;/p&gt;

&lt;p&gt;변경과 관련이 있는 어떤 것에도 의존성이라는 개념을 적용할 수 있다. 의존성의 대상은 객체일 수도 있고 모듈이나 더 큰 규모의 실행 시스템일 수도 있다. 하지만 의존성의 본질은 변하지 않는다. &lt;strong&gt;의존성이란&lt;/strong&gt; 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이다.&lt;/p&gt;

&lt;h3 id=&quot;런타임-의존성과-컴파일타임-의존성&quot;&gt;런타임 의존성과 컴파일타임 의존성&lt;/h3&gt;

&lt;p&gt;의존성과 관련해서 다뤄야 하는 또 다른 주제는 &lt;strong&gt;런타임 의존성(run-time dependency)&lt;/strong&gt; 과 &lt;strong&gt;컴파일타임 의존성(compile-time dependency)&lt;/strong&gt; 의 차이다. &lt;strong&gt;런타임&lt;/strong&gt;은 말 그대로 애플리케이션이 실행되는 시점을 가리킨다. 일반적으로 &lt;strong&gt;컴파일타임&lt;/strong&gt;이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키기도 한다.&lt;/p&gt;

&lt;p&gt;컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 &lt;strong&gt;코드의 구조&lt;/strong&gt;이기 때문이다.&lt;/p&gt;

&lt;p&gt;객체지향 애플리케이션에서 &lt;strong&gt;런타임의 주인공&lt;/strong&gt;은 객체다. &lt;strong&gt;런타임 의존성&lt;/strong&gt;이 다루는 주제는 객체 사이의 의존성이다. 반면 &lt;strong&gt;코드 관점에서 주인공&lt;/strong&gt;은 클래스다. 따라서 &lt;strong&gt;컴파일타임 의존성&lt;/strong&gt;이 다루는 주제는 클래스 사이의 의존성이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/82863279-aeff5c80-9f5c-11ea-8242-ac3ac5ce2cc5.png&quot; alt=&quot;8.2.png&quot; /&gt;
&lt;i&gt;&lt;b&gt;그림 8.2&lt;/b&gt; 코드 작성 시점의 Movie와 DiscountPolicy 사이의 의존성&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Movie는 가격을 계산하기 위해 비율 할인 정책과 금액 할인 정책 모두를 적용할 수 있게 설계해야 한다. 따라서 추상클래스인 DiscountPolicy에 의존하도록 설계했다.&lt;/p&gt;

&lt;p&gt;하지만 런타임 의존성을 살펴보면 상황이 완전히 달라진다.
&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/82863280-af97f300-9f5c-11ea-95b8-2efd6af3485a.png&quot; alt=&quot;8.3.png&quot; /&gt;
&lt;i&gt;&lt;b&gt;그림 8.3&lt;/b&gt; Movie의 인스턴스가 가지는 런타임 의존성&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Movie의 인스턴스가 이 두 클래스의 인스턴스와 함께 협력할 수 있게 만드는 더 나은 방법은 Movie가 두 클래스 중 어떤 것도 알지 못하게 만드는 것이다. 두 클래스 모두를 포괄하는 DiscountPolicy라는 추상 클래스에 의존하도록 만들고, &lt;strong&gt;컴파일타임 의존성&lt;/strong&gt;을 실행시에 &lt;strong&gt;런타임 의존성&lt;/strong&gt;으로 대체해야 한다.&lt;/p&gt;

&lt;p&gt;어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안 된다. 실제로 협력할 객체가 어떤 것인지는 &lt;strong&gt;런타임에 해결&lt;/strong&gt;해야 한다. 따라서 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계까 유연해지고 재사용 가능해진다.&lt;/p&gt;

&lt;h3 id=&quot;컨텍스트-독립성&quot;&gt;컨텍스트 독립성&lt;/h3&gt;

&lt;p&gt;클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안 된다. 구체적인 클래스를 알면 알수록 그 클래스가 사용되는 &lt;strong&gt;특정한 문맥에 강하게 결합&lt;/strong&gt;되기 때문이다.&lt;/p&gt;

&lt;p&gt;구체적인 문맥은 컴파일타임 의존성을 어떤 런타임 의존성으로 대체하느냐에 따라 달라질 것이다. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 &lt;strong&gt;컨텍스트 독립성&lt;/strong&gt;이라고 부른다.&lt;/p&gt;

&lt;p&gt;설계가 유연해지기 위해서는 자신이 실행될 컨텍스트에 대한 구체적인 정보를 &lt;strong&gt;최대한 적게&lt;/strong&gt; 알아야 한다. 컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;의존성-해결하기&quot;&gt;의존성 해결하기&lt;/h3&gt;

&lt;p&gt;컴파일타임 의존성은 &lt;strong&gt;구체적인 런타임 의존성&lt;/strong&gt;으로 대체돼야 한다. 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 &lt;strong&gt;의존성 해결&lt;/strong&gt;이라고 부른다. 의존성을 해결하기 위해서 일반적으로 다음과 같은 세 가지 방법을 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체를 생성하는 시점에 생성자를 통해 의존성 해결&lt;/li&gt;
  &lt;li&gt;객체 생성 후 setter 메소드를 통해 의존성 해결&lt;/li&gt;
  &lt;li&gt;메서드 실행 시 인자를 이용해 의존성 해결&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;setter 메서드&lt;/strong&gt;를 이용하는 방식은 객체를 생성한 이후에도 의존하고 있는 대상을 변경할 수 있는 가능성을 열어 놓고 싶은 경우에 유용하다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PercentDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;setter 메서드를 이용하는 방법은 &lt;strong&gt;실행 시점에 의존 대상을 변경&lt;/strong&gt;할 수 있기 때문에 설계를 좀 더 유연하게 만들 수 있다. 단점은 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전까지 &lt;strong&gt;객체의 상태가 불완전&lt;/strong&gt;할 수 있다는 점이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;calculateFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...);&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 예외 발생&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;더 좋은 방법은 &lt;strong&gt;생성자 방식과 setter 방식을 혼합&lt;/strong&gt;하는 것이다. 이 방법은 시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬 수 있기 때문에 의존성 해결을 위해 가장 선호되는 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PercentDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;avatar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Movie가 항상 할인 정책을 알 필요까지는 없고 가격을 계산할 때만 일시적으로 알아도 무방하다면 메서드의 인자를 이용해 의존성을 해결할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateMovieFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;minus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;calculateDiscountAmount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;메서드 인자&lt;/strong&gt;를 사용하는 방식은 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없을 경우 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;유연한-설계&quot;&gt;유연한 설계&lt;/h2&gt;

&lt;h3 id=&quot;의존성과-결합도&quot;&gt;의존성과 결합도&lt;/h3&gt;

&lt;p&gt;Movie가 비율 할인 정책을 구현하는 PercentDiscountPolicy에 직접 의존한다고 가정해보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PercentDiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;percentDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문제는 의존성의 존재가 아니라 &lt;strong&gt;의존성의 정도&lt;/strong&gt;다. 이 코드에서 Movie는 구체적인 클래스에 의존하기 때문에 다른 종류의 할인 정책이 필요한 문맥에서 Movie를 재사용할 수 있는 가능성을 없애 버렸다.&lt;/p&gt;

&lt;p&gt;해결 방법은 &lt;strong&gt;의존성을 바람직하게&lt;/strong&gt; 만드는 것이다. Movie의 입장에서는 협력할 객체의 클래스를 고정할 필요가 없다. 자신이 전송하는 메시지를 이해할 수 있다면 어떤 타입의 객체와 협력하더라도 상관이 없다.&lt;/p&gt;

&lt;p&gt;바람직한 의존성은 &lt;strong&gt;재사용성&lt;/strong&gt;과 관련이 있다. 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다. 다시 말해 &lt;strong&gt;컨텍스트에 독립적&lt;/strong&gt;인 의존성은 &lt;strong&gt;바람직한 의존성&lt;/strong&gt;이고 특정 &lt;strong&gt;컨텍스트에 강하게 결합&lt;/strong&gt;된 의존성은 &lt;strong&gt;바람직하지 않은 의존성&lt;/strong&gt;이다. 특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변경하는 것뿐이다.&lt;/p&gt;

&lt;p&gt;어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 &lt;strong&gt;느슨한 결합도(loose coupling)&lt;/strong&gt; 또는 &lt;strong&gt;약한 결합도(weak coupling)&lt;/strong&gt; 를 가진다고 말한다. 반대로 두 요소 사이의 의존성이 바람직하지 못할 때 &lt;strong&gt;단단한 결합도(tight coupling)&lt;/strong&gt; 또는 &lt;strong&gt;강한 결합도(strong coupling)&lt;/strong&gt; 를 가진다고 말한다.&lt;/p&gt;

&lt;h3 id=&quot;지식이-결합을-낳는다&quot;&gt;지식이 결합을 낳는다&lt;/h3&gt;

&lt;p&gt;결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 &lt;strong&gt;정보의 양&lt;/strong&gt;으로 결정된다. 한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을수록 두 요소는 강하게 결합된다.
&lt;strong&gt;더 많이 알수록 더 많이 결합된다.&lt;/strong&gt; 더 많이 알고 있다는 것은 더 적은 컨텍스트에서 재사용 가능하다는 것을 의미한다. 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 &lt;strong&gt;필요한 정보 외에는 최대한 감추는 것&lt;/strong&gt;이 중요하다.&lt;/p&gt;

&lt;h3 id=&quot;추상화에-의존하라&quot;&gt;추상화에 의존하라&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;추상화&lt;/strong&gt;란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.&lt;/p&gt;

&lt;p&gt;일반적으로 추상화와 결합도의 관점에서 의존 대상을 다음과 같이 구분하는 것이 유용하다. 목록에서 아래쪽으로 갈수록 클라이언트가 알아야 하는 지식의 양이 적어지기 때문에 결합도가 느슨해진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구체 클래스 의존성(concrete class dependency)&lt;/li&gt;
  &lt;li&gt;추상 클래스 의존성(abstract class dependency)&lt;/li&gt;
  &lt;li&gt;인터페이스 의존성(interface dependency)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구체 클래스에 비해 &lt;strong&gt;추상 클래스&lt;/strong&gt;는 메서드의 내부 구현과 자식 클래스의 종류에 대한 지식을 클라이언트에게 숨길 수 있다. 하지만 추상 클래스의 클라이언트는 여전히 협력하는 대상이 속한 &lt;strong&gt;클래스 상속 계층&lt;/strong&gt;이 무엇인지에 대해서는 알고 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;인터페이스 의존성&lt;/strong&gt;은 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만을 남기기 때문에 추상 클래스 의존성보다 결합도가 낮다.&lt;/p&gt;

&lt;p&gt;중요한 것은 실행 컨텍스트에 대해 &lt;strong&gt;알아야 하는 정보를 줄일수록 결합도가 낮아진다&lt;/strong&gt;는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;명시적인-의존성&quot;&gt;명시적인 의존성&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runningTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드의 생성자에서 구체 클래스인 AmountDiscountPolicy의 인스턴스를 직접 생성해서 대입하고 있다. 따라서 Movie는 구체 클래스인 AmountDiscountPolicy에도 의존하게 된다. 예제에서 알 수 있는 것처럼 결합도를 느슨하게 만들기 위해서는 클래스 안에서 &lt;strong&gt;구체 클래스에 대한 모든 의존성을 제거&lt;/strong&gt;해야만 한다. 다시 말해 Movie의 의존성을 해결해 줄 수 있는 방법이 필요한 것이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runningTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                            &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성자의 인자가 추상 클래스 타입으로 선언됐기 때문에 객체를 생성할 때 생성자의 인자로 DiscountPolicy의 자식 클래스 중 어떤 것이라도 전달할 수 있다.&lt;/p&gt;

&lt;p&gt;의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법 사이의 가장 큰 &lt;strong&gt;차이점&lt;/strong&gt;은 &lt;strong&gt;퍼블릭 인터페이스&lt;/strong&gt;를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지 여부다. 생성자의 인자로 선언하는 방법은 의존 사실을 퍼블릭 인터페이스에 드러내는 것이다. 이를 &lt;strong&gt;명시적인 의존성(explicit dependency)&lt;/strong&gt; 이라고 부른다.&lt;/p&gt;

&lt;p&gt;반면 클래스 내부에서 인스턴스를 직접 생성하는 방식은 의존성을 감춘다. 다시 말해 의존성이 퍼블릭 인터페이스에 표현되지 않는다. 이를 &lt;strong&gt;숨겨진 의존성(hidden dependency)&lt;/strong&gt; 이라고 부른다.&lt;/p&gt;

&lt;p&gt;의존성이 명시적이지 않으면 의존성을 파악하기 위해 &lt;strong&gt;내부 구현&lt;/strong&gt;을 직접 살펴볼 수 밖에 없다. 더 커다란 문제는 클래스를 다른 컨텍스트에서 &lt;strong&gt;재사용&lt;/strong&gt;하기 위해 내부 구현을 직접 변경해야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;의존성은 &lt;strong&gt;명시적&lt;/strong&gt;으로 표현돼야 한다. 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다. 경계해야 할 것은 의존성 자체가 아니라 &lt;strong&gt;의존성을 감추는 것&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h3 id=&quot;new는-해롭다&quot;&gt;new는 해롭다&lt;/h3&gt;

&lt;p&gt;결합도 측면에서 new가 해로운 이유는 크게 두 가지이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도가 높아진다.&lt;/li&gt;
  &lt;li&gt;new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. 따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;new는 결합도를 높이기 때문에 해롭다. 해결 방법은 &lt;strong&gt;인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리&lt;/strong&gt;하는 것이다. &lt;strong&gt;사용과 생성의 책임을 분리&lt;/strong&gt;하고, &lt;strong&gt;의존성을 생성자에 명시적으로 드러내&lt;/strong&gt;고, &lt;strong&gt;구체 클래스가 아닌 추상 클래스에 의존&lt;/strong&gt;하게 함으로써 설계를 유연하게 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;가끔은-생성해도-무방하다&quot;&gt;가끔은 생성해도 무방하다&lt;/h3&gt;

&lt;p&gt;클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다. 주로 &lt;strong&gt;협력하는 기본 객체를 설정&lt;/strong&gt;하고 싶은 경우가 여기에 속한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runningTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runningTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AmountDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Movie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Duration&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runningTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                                                    &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성자가 체인처럼 연결된다. 이 방법은 메서드를 오버로딩하는 경우에도 사용할 수 있다. 인스턴스를 인자로 받는 메서드와 기본값을 생성하는 메서드를 함께 사용한다면 클래스의 &lt;strong&gt;사용성을 향상&lt;/strong&gt;시키면서도 &lt;strong&gt;다양한 컨텍스트에서 유연하게 사용될 수 있는 여지를 제공&lt;/strong&gt;할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;표준-클래스에-대한-의존은-해롭지-않다&quot;&gt;표준 클래스에 대한 의존은 해롭지 않다.&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountCondition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conditions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;비록 클래스를 직접 생성하더라도 가능한 한 추상적인 타입을 사용하는 것이 확장성 측면에서 유리하다.&lt;/p&gt;

&lt;h3 id=&quot;조합-가능한-행동&quot;&gt;조합 가능한 행동&lt;/h3&gt;

&lt;p&gt;어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 &lt;strong&gt;유연하고 재사용 가능한 설계&lt;/strong&gt;가 가진 특징이다. 유연하고 재사용 가능한 설계는 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써 애플리케이션의 기능을 쉽게 확장할 수 있다.&lt;/p&gt;

&lt;p&gt;유연하고 재사용 가능한 설계는 객체가 &lt;strong&gt;어떻게(how)&lt;/strong&gt; 하는지를 장황하게 나열하지 않고도 객체들의 조합을 통해 &lt;strong&gt;무엇(what)&lt;/strong&gt; 을 하는지를 표현하는 클래스들로 구성된다. 다시 말해 선언적으로 객체의 행동을 정의할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;유연하고 재사용 가능한 설계&lt;/strong&gt;는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다. &lt;strong&gt;훌륭한 객체지향 설계&lt;/strong&gt;란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다. 이런 설계를 창조하는 데 있어서의 핵심은 &lt;strong&gt;의존성을 관리&lt;/strong&gt;하는 것이다.&lt;/p&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><category term="Study" /><category term="Object" /><category term="OOP" /><category term="UML" /><category term="Study" /><category term="요약" /><category term="정리" /><summary type="html">Object 8장 요약</summary></entry><entry><title type="html">[Object] 7장</title><link href="http://localhost:4000/study/object-chapter7/" rel="alternate" type="text/html" title="[Object] 7장" /><published>2020-05-26T00:00:00+09:00</published><updated>2020-05-26T00:00:00+09:00</updated><id>http://localhost:4000/study/object-chapter7</id><content type="html" xml:base="http://localhost:4000/study/object-chapter7/">&lt;h1 id=&quot;7-객체-분해&quot;&gt;7. 객체 분해&lt;/h1&gt;

&lt;p&gt;불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업을 &lt;strong&gt;추상화&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;가장 일반적인 추상화 방법은 한 번에 다뤄야 하는 문제의 크기를 줄이는 것이다. 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 &lt;strong&gt;분해(decomposition)&lt;/strong&gt; 라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
분해의 목적은 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;프로시저-추상화와-데이터-추상화&quot;&gt;프로시저 추상화와 데이터 추상화&lt;/h2&gt;

&lt;p&gt;모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.
현대적인 프로그래밍 언어를 특정 짓는 중요한 두 가지 추상화 매커니즘은 &lt;strong&gt;프로시저 추상화(procedure abstraction)&lt;/strong&gt; 와 &lt;strong&gt;데이터 추상화(data abstraction)&lt;/strong&gt; 다.&lt;/p&gt;

&lt;p&gt;프로시저 추상화는 소프트웨어가 무엇을 해야 하는지를 추상화한다.
데이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화한다.
소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다.&lt;/p&gt;

&lt;p&gt;프로그래밍 패러다임이란 적절한 추상화의 윤곽을 따라 시스템을 어떤 식으로 나눌 것인지를 결정하는 &lt;strong&gt;원칙과 방법의 집합&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;프로시저 추상화를 중심으로 시스템을 분해하기로 결정했다면 &lt;strong&gt;기능 분해(functional decomposition)&lt;/strong&gt; 의 길로 들어서는 것이다. 기능 분해는 &lt;strong&gt;알고리즘 분해(algorithmic decomposition)&lt;/strong&gt; 라고 부르기도 한다.&lt;/p&gt;

&lt;p&gt;데이터를 중심으로 시스템을 분해하기로 결정했다면 다시 두 가지 중 하나를 선택해야 한다. 하나는 데이터를 중심으로 &lt;strong&gt;타입을 추상화(type abstraction)&lt;/strong&gt; 하는 것이고 다른 하나는 데이터를 중심으로 &lt;strong&gt;프로시저를 추상화(procedure abstraction)&lt;/strong&gt; 하는 것이다. 전자를 &lt;strong&gt;추상 데이터 타입(Abstract Data Type)&lt;/strong&gt; 이라고 부르고 후자를 &lt;strong&gt;객체지향(Object-Oriented)&lt;/strong&gt; 이라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;역할과 책임을 수행하는 객체&lt;/code&gt;가 바로 객체지향 패러다임이 이용하는 추상화다. 기능을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;협력하는 공동체&lt;/code&gt;를 구성하도록 객체들을 나누는 과정이 바로 객체지향 패러다임에서의 &lt;strong&gt;분해&lt;/strong&gt;를 의미한다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어의 관점에서 &lt;strong&gt;객체지향&lt;/strong&gt;이란 데이터를 중심으로 &lt;strong&gt;데이터 추상화&lt;/strong&gt;와 &lt;strong&gt;프로시저 추상화&lt;/strong&gt;를 통합한 객체를 이용해 시스템을 분해하는 방법이다. 따라서 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 &lt;strong&gt;분해&lt;/strong&gt;하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;프로시저-추상화와-기능-분해&quot;&gt;프로시저 추상화와 기능 분해&lt;/h2&gt;

&lt;h3 id=&quot;메인-함수로서의-시스템&quot;&gt;메인 함수로서의 시스템&lt;/h3&gt;

&lt;p&gt;기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용됐으며, 이 같은 시스템 분해 방식을 &lt;strong&gt;알고리즘 분해&lt;/strong&gt; 또는 &lt;strong&gt;기능 분해&lt;/strong&gt;라고 부른다. 기능 분해의 관점에서 추상화의 단위는 &lt;strong&gt;프로시저&lt;/strong&gt;이며 시스템은 프로시저를 단위로 분해된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로시저&lt;/strong&gt;는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다. 프로시저를 추상화라고 부르는 이유는 내부의 상세한 구현 내용을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;전통적인 기능 분해 방법은 &lt;strong&gt;하향식 접근법(Top-Down Approach)&lt;/strong&gt; 으 따른다. 하향식 접근법이란 시스템을 구성하는 가장 최상위(topmost) 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다.
분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속된다.&lt;/p&gt;

&lt;h3 id=&quot;급여-관리-시스템&quot;&gt;급여 관리 시스템&lt;/h3&gt;

&lt;p&gt;기능 분해 방법을 이용하여 급여 관리 시스템을 구현한다. 전통적으로 기능 분해 방법은 &lt;strong&gt;하향식 접근법&lt;/strong&gt;을 따르며 단계적인 정제 절차를 따라 시스템을 구축한다. 기능 분해의 초점은 하나의 문장으로 표현된 기능을 여러 개의 더 작은 기능으로 분해하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;직원의 급여를 계산한다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;좀 더 세분화된 절차로 구체화해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;직원의 급여를 계산한다
  사용자로부터 소득세율을 입력받는다
  직원의 급여를 계산한다
  양식에 맞게 결과를 출력한다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모든 문장이 정제 과정을 거치면서 하나 이상의 좀 더 단순하고 구체적인 &lt;strong&gt;문장들의 조합&lt;/strong&gt;으로 분해돼야 한다. 만약 좀 더 정제 가능한 문장이 존재하면 동일한 과정을 거쳐 구현이 가능할 정도로 충분히 저수준의 문장이 될 때까지 기능을 분해해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;직원의 급여를 계산한다
  사용자로부터 소득세율을 입력받는다
    &quot;세율을 입력하세요: &quot;라는 문장을 화면에 출력한다
    키보드를 통해 세율을 입력받는다
  직원의 급여를 계산한다
    전역 변수에 저장된 직원의 기본급 정보를 얻는다
    급여를 계산한다
  양식에 맞게 결과를 출력한다
    &quot;이름: {직원명}, 급여: {계산된 금액}&quot; 형식에 따라 출력 문자열을 생성한다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 &lt;strong&gt;시간 순서&lt;/strong&gt;에 따라 나열한 것이다.&lt;/p&gt;

&lt;p&gt;기능 분해 방법에서는 &lt;strong&gt;기능을 중심&lt;/strong&gt;으로 필요한 데이터를 결정한다. 먼저 필요한 기능을 생각하고 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다. 하지만 이 방법은 유지보수에 다양한 문제를 야기한다.&lt;/p&gt;

&lt;h3 id=&quot;급여-관리-시스템-구현&quot;&gt;급여 관리 시스템 구현&lt;/h3&gt;

&lt;p&gt;하향식 기능 분해 방식으로 설계한 시스템은 메인 함수를 루트로 하는 &lt;strong&gt;트리(tree)&lt;/strong&gt; 로 표현할 수 있다. 트리에서 각 노드(node)는 시스템을 구성하는 프로시저를 의미하고 한 노드의 자식 노드는 부모 노드를 구현하는 절차 중의 한 단계를 의미한다.
&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/82863275-ae66c600-9f5c-11ea-8ea2-9839d1040e45.png&quot; alt=&quot;7.1.png&quot; /&gt;
&lt;i&gt;&lt;b&gt;그림 7.1&lt;/b&gt; 트리 형태로 표현한 급여 관리 시스템의 기능 분해 구조&lt;/i&gt;&lt;/p&gt;

&lt;h3 id=&quot;하향식-기능-분해의-문제점&quot;&gt;하향식 기능 분해의 문제점&lt;/h3&gt;

&lt;p&gt;하향식 기능 분해 방법을 실제 설계에 적용하다 보면 다음과 같은 다양한 문제에 직면한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템은 하나의 메인 함수로 구성돼 있지 않다.&lt;/li&gt;
  &lt;li&gt;기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.&lt;/li&gt;
  &lt;li&gt;비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.&lt;/li&gt;
  &lt;li&gt;하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.&lt;/li&gt;
  &lt;li&gt;데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하향식 접근법과 기능 분해가 가지는 근본적인 문제점은 변경에 취약한 설계를 낳는다.&lt;/p&gt;

&lt;h3 id=&quot;하나의-메인-함수라는-비현실적인-아이디어&quot;&gt;하나의 메인 함수라는 비현실적인 아이디어&lt;/h3&gt;

&lt;p&gt;어떤 시스템도 최초에 릴리스됐던 당시의 모습을 그대로 유지하지는 않는다. 어느 시점에 이르면 &lt;i&gt;유일한&lt;/i&gt; 메인 함수라는 개념은 의미가 없어지고 시스템은 여러 개의 동등한 수준의 함수 집합으로 성장하게 된다. 대부분의 시스템에서 &lt;strong&gt;하나의 메인 기능이란 개념은 존재하지 않는다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;메인-함수의-빈번한-재설계&quot;&gt;메인 함수의 빈번한 재설계&lt;/h3&gt;

&lt;p&gt;하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다. 기존 코드를 수정하는 것은 항상 새로운 버그를 만들어낼 확률을 높인다는 점에 주의하라. 기존 코드의 &lt;strong&gt;빈번한 수정&lt;/strong&gt;으로 인한 버그 발생 확률이 높아지기 때문에 시스템은 &lt;strong&gt;변경에 취약&lt;/strong&gt;해질 수밖에 없다.&lt;/p&gt;

&lt;h3 id=&quot;비즈니스-로직과-사용자-인터페이스의-결합&quot;&gt;비즈니스 로직과 사용자 인터페이스의 결합&lt;/h3&gt;

&lt;p&gt;하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다. 결과적으로 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.&lt;/p&gt;

&lt;p&gt;문제는 비즈니스 로직과 사용자 인터페이스가 변경되는 빈도가 다르다는 것이다. 하향식 접근법에서 사용자 인터페이스를 변경하는 경우 비즈니스 로직까지 변경에 영향을 받게 된다. 하향식 접근법은 &lt;strong&gt;“관심사의 분리”&lt;/strong&gt; 라는 아키텍처 설계의 목적을 달성하기 어렵다.&lt;/p&gt;

&lt;h3 id=&quot;성급하게-결정된-실행-순서&quot;&gt;성급하게 결정된 실행 순서&lt;/h3&gt;

&lt;p&gt;하향식으로 기능을 분해하는 과정은 하나의 함수를 더 작은 함수로 분해하고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약할 수 있다. 이것은 설계하는 시점부터 시스템이 &lt;strong&gt;무엇(what)&lt;/strong&gt; 을 해야 하는지가 아니라 &lt;strong&gt;어떻게(how)&lt;/strong&gt; 동작해야 하는지에 집중하도록 만든다.&lt;/p&gt;

&lt;p&gt;하향식 접근법의 설계는 처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 실행 순서를 정의하는 &lt;strong&gt;시간 제약(temporal constraint)&lt;/strong&gt; 을 강조한다. 메인 함수가 작은 함수들로 분해되기 위해서는 우선 함수들의 순서를 결정해야 한다.&lt;/p&gt;

&lt;p&gt;기능 분해 방식은 &lt;strong&gt;중앙집중 제어 스타일(centralized control style)&lt;/strong&gt; 의 형태를 띨 수밖에 없다. 결과적으로 모든 중요한 제어 흐름의 결정이 상위 함수에서 이뤄지고 하위 함수는 상위 함수의 흐름에 따라 적절한 시점에 호출된다.&lt;/p&gt;

&lt;p&gt;문제는 중요한 설계 결정사항인 함수의 제어구조가 빈번한 &lt;strong&gt;변경의 대상&lt;/strong&gt;이라는 점이다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해서는 자주 변경되는 시간적인 제약에 대한 미련을 버리고 좀 더 안정적인 &lt;strong&gt;논리적 제약(logical constraint)&lt;/strong&gt; 을 설계의 기준으로 삼는 것이다. 객체지향은 함수 간의 호출 순서가 아니라 객체 사이의 논리적인 관계를 중심으로 설계를 이끌어간다. 결과적으로 여러 객체들 사이로 &lt;strong&gt;제어 주체가 분산&lt;/strong&gt;된다.&lt;/p&gt;

&lt;p&gt;하향식 접근법을 통해 분해한 함수들은 재사용하기도 어렵다. 모든 함수는 상위 함수가 강요하는 &lt;strong&gt;문맥(context)&lt;/strong&gt; 안에서만 의미를 가지기 때문이다. 하향식 접근법을 따를 경우 분해된 함수는 항상 상위 함수보다 문맥에 더 종속적이다.&lt;/p&gt;

&lt;p&gt;하향식 설계와 관련된 모든 문제의 원인은 &lt;strong&gt;결합도&lt;/strong&gt;다. 강한 결합도는 시스템을 변경에 취약하게 만들고 이해하기 어렵게 만든다. 가장 큰 문제는 전체 시스템의 핵심적인 구조를 결정하는 함수들이 데이터와 강하게 결합된다는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-변경으로-인한-파급효과&quot;&gt;데이터 변경으로 인한 파급효과&lt;/h3&gt;

&lt;p&gt;하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다는 것이다. 따라서 &lt;strong&gt;데이터 변경&lt;/strong&gt;으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다. 어떤 데이터가 어떤 함수에 의존하고 있는지를 파악하는 것은 어려운 일이다. 이것은 의존성과 결합도 문제이다.&lt;/p&gt;

&lt;p&gt;데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것이 생각보다 쉽지 않다. 코드가 성장하고 라인 수가 증가할수록 전역 데이터를 변경하는 것은 악몽으로 변해간다.&lt;/p&gt;

&lt;p&gt;데이터 변경으로 인한 영향을 &lt;strong&gt;최소화&lt;/strong&gt;하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다. 잘 정의된 &lt;strong&gt;퍼블릭 인터페이스&lt;/strong&gt;를 통해 데이터에 대한 접근을 통제해야 한다.&lt;/p&gt;

&lt;p&gt;이것이 &lt;strong&gt;의존성 관리의 핵심&lt;/strong&gt;이다. 변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 받지 않는 부분을 명확하게 분리하고 잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제하라. 데이비드 파나스(David Parnas)는 이 같은 개념을 기반으로 한 &lt;strong&gt;정보 은닉&lt;/strong&gt;과 &lt;strong&gt;모듈&lt;/strong&gt;이라는 개념을 제시하였다.&lt;/p&gt;

&lt;h3 id=&quot;언제-하향식-분해가-유용한가&quot;&gt;언제 하향식 분해가 유용한가?&lt;/h3&gt;

&lt;p&gt;하향식 아이디어가 매력적인 이유는 설계가 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하기 때문이다. 하향식은 &lt;strong&gt;이미 완전히 이해된 사실을 서술하기에 적합한 방법&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h2 id=&quot;모듈&quot;&gt;모듈&lt;/h2&gt;

&lt;h3 id=&quot;정보-은닉과-모듈&quot;&gt;정보 은닉과 모듈&lt;/h3&gt;

&lt;p&gt;기능을 기반으로 시스템을 분해하는 것이 아니라 &lt;strong&gt;변경에 방향&lt;/strong&gt;에 맞춰 시스템을 분해해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정보 은닉(information hiding)&lt;/strong&gt; 은 &lt;strong&gt;시스템을 모듈 단위로 분해하기 위한 기본 원리&lt;/strong&gt;로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심이다.&lt;/p&gt;

&lt;p&gt;모듈은 서브 프로그램이라기보다는 &lt;strong&gt;책임의 할당&lt;/strong&gt;이다. 모듈화는 개별적인 모듈에 대한 작업이 시작되기 전에 정해져야 하는 설계 결정들을 포함한다. 어려운 설계 결정이나 변화할 것 같은 설계 결정들의 목록을 사용해 설계를 시작할 것을 권장한다.&lt;/p&gt;

&lt;p&gt;정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 &lt;strong&gt;모듈 분할 원리&lt;/strong&gt;다. 모듈은 변경될 가능성이 있는 &lt;strong&gt;비밀을 내부&lt;/strong&gt;로 감추고, 쉽게 변경되지 않을 &lt;strong&gt;퍼블릭 인터페이스를 외부&lt;/strong&gt;에 제공해서 내부의 비밀에 함부로 접근하지 못하게 한다.&lt;/p&gt;

&lt;p&gt;기능 분해가 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 &lt;strong&gt;탐색의 과정&lt;/strong&gt;이라면 모듈 분해는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 &lt;strong&gt;보존의 과정&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;복잡성&lt;/strong&gt; : 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;변경 가능성&lt;/strong&gt; : 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;모듈의-장점과-한계&quot;&gt;모듈의 장점과 한계&lt;/h3&gt;

&lt;p&gt;모듈의 장점은 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다&lt;/strong&gt;
모듈을 사용하면 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다. 모듈은 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드를 수정하고 디버깅하기가 더 용이하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다&lt;/strong&gt;
다른 형식의 사용자 인터페이스를 추가하더라도 모듈에 포함된 비즈니스 로직은 변경되지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다&lt;/strong&gt;
모듈은 네임스페이스의 오염을 방지하는 동시에 이름 충돌(name collision)의 위험을 완화한다.&lt;/p&gt;

&lt;p&gt;모듈은 기능이 아니라 &lt;strong&gt;변경의 정도&lt;/strong&gt;에 따라 시스템을 분해하게 한다. 따라서 모듈 내부는 &lt;em&gt;높은 응집도&lt;/em&gt;를 유지한다. 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신해야 한다. 따라서 &lt;em&gt;낮은 결합도&lt;/em&gt;를 유지한다.&lt;/p&gt;

&lt;p&gt;하향식 기능 분해와 달리 모듈은 감춰야 할 데이터를 결정하고 데이터를 조작하는 데 필요한 함수를 결정한다. 다시 말해 기능이 아니라 &lt;strong&gt;데이터를 중심&lt;/strong&gt;으로 시스템을 분해한다. 모듈은 데이터와 함수가 통합된 한 차원 높은 추상화를 제공하는 설계 단위다.&lt;/p&gt;

&lt;p&gt;모듈이 프로시저 추상화보다는 높은 추상화 개념을 제공하지만 추상화 관점에서의 한계점이 명확하다. 모듈의 가장 큰 단점은 &lt;strong&gt;인스턴스의 개념을 제공하지 않는다&lt;/strong&gt;는 점이다.&lt;/p&gt;

&lt;h2 id=&quot;데이터-추상화와-추상-데이터-타입&quot;&gt;데이터 추상화와 추상 데이터 타입&lt;/h2&gt;

&lt;h3 id=&quot;추상-데이터-타입&quot;&gt;추상 데이터 타입&lt;/h3&gt;

&lt;p&gt;프로그래밍 언어에서 &lt;strong&gt;타입(type)&lt;/strong&gt; 이란 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.&lt;/p&gt;

&lt;p&gt;바바라 리스코프(Barbara Liskov)는 프로시저 추상화를 보완하기 위해 &lt;strong&gt;데이터 추상화(data abstraction)&lt;/strong&gt; 의 개념을 제안했다. 추상 데이터 타입은 추상 객체의 클래스를 정의한 것으로 추상 객체에 사용할 수 있는 &lt;strong&gt;오퍼레이션&lt;/strong&gt;을 이용해 규정된다. 추상 데이터 객체를 사용할 때 프로그래머는 오직 객체가 외부에 제공하는 행위에만 관심을 가지며 행위가 구현되는 세부적인 사항에 대해서는 무시한다.&lt;/p&gt;

&lt;p&gt;추상 데이터 타입은 말 그대로 시스템의 상태를 저장할 데이터를 표현한다. 데이터에 대한 관점을 설계 표면으로 끌어올리기는 하지만 여전히 데이터와 기능을 분리하는 &lt;strong&gt;절차적인 설계&lt;/strong&gt;의 틀에 갇혀 있다.&lt;/p&gt;

&lt;h2 id=&quot;클래스&quot;&gt;클래스&lt;/h2&gt;

&lt;h3 id=&quot;클래스는-추상-데이터-타입인가&quot;&gt;클래스는 추상 데이터 타입인가?&lt;/h3&gt;

&lt;p&gt;클래스와 추상 데이터 타입의 가장 핵심적인 차이는 &lt;strong&gt;클래스&lt;/strong&gt;는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다는 점이다. 상속과 다형성을 지원하는 &lt;strong&gt;객체지향 프로그래밍(Object-Oriented Programming)&lt;/strong&gt; 과 구분하기 위해 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 패러다임을 &lt;strong&gt;객체기반 프로그래밍(Object-Based Programming)&lt;/strong&gt; 이라고 부른다.&lt;/p&gt;

&lt;p&gt;윌리엄 쿡(William Cook)은 추상 데이터 타입은 타입을 추상화한 것(type abstraction)이고 클래스는 절차를 추상화한 것(procedural abstraction)이라고 정의하였다.
윌리엄 쿡은 하나의 &lt;strong&gt;대표적인 타입&lt;/strong&gt;이 다수의 세부적인 타입을 감추기 때문에 이를 &lt;strong&gt;타입 추상화&lt;/strong&gt;라고 불렀다. 타입 추상화는 개별 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄하도록 함으로써 하나의 물리적인 타입 안에 전체 타입을 감춘다. 따라서 &lt;strong&gt;타입 추상화&lt;/strong&gt;는 &lt;strong&gt;오퍼레이션을 기준&lt;/strong&gt;으로 타입을 통합하는 데이터 추상화 기법이다.&lt;/p&gt;

&lt;p&gt;객체지향은 &lt;strong&gt;타입을 기준&lt;/strong&gt;으로 오퍼레이션을 묶는다. 클래스의 공통 로직은 부모 클래스를 정의하고 하위 클래스가 부모 클래스를 상속받게 한다. 즉, 동일한 메시지에 대해 서로 다르게 반응한다. 이것이 바로 다형성이다. 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다. 다시 말해 객체지향은 &lt;strong&gt;절차 추상화(procedural abstraction)&lt;/strong&gt; 다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;추상 데이터 타입&lt;/strong&gt;은 &lt;strong&gt;오퍼레이션을 기준&lt;/strong&gt;으로 타입들을 추상화한다. &lt;strong&gt;클래스&lt;/strong&gt;는 &lt;strong&gt;타입을 기준&lt;/strong&gt;으로 절차들을 추상화한다.&lt;/p&gt;

&lt;h3 id=&quot;변경을-기준으로-선택하라&quot;&gt;변경을 기준으로 선택하라&lt;/h3&gt;

&lt;p&gt;클래스가 추상 데이터 타입의 개념을 따르는지를 확인할 수 있는 가장 간단한 방법은 클래스 내부에 &lt;strong&gt;인스턴스의 타입을 표현하는 변수&lt;/strong&gt;가 있는지를 살펴보는 것이다. 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 &lt;strong&gt;위반&lt;/strong&gt;하는 것으로 간주된다.&lt;/p&gt;

&lt;p&gt;객체지향에서는 타입 변수를 이용한 조건문을 &lt;strong&gt;다형성&lt;/strong&gt;으로 대체한다. 조건문을 사용하는 방식을 기피하는 이유는 변경때문이다. 객체 지향은 새로운 유형을 구현하는 클래스를 상속 계층에 추가하고 필요한 메서드를 오버라이딩하면 된다. 이것은 시스템에 새로운 로직을 추가하기 위해 클라이언트 코드를 수정할 필요가 없다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 &lt;strong&gt;개방-폐쇄 원칙(Open-Closed Principle, OCP)&lt;/strong&gt; 이라고 부른다. 이것이 객체지향 설계가 전통적인 방식에 비해 변경하고 확장하기 쉬운 구조로 설계할 수 있는 이유다.&lt;/p&gt;

&lt;p&gt;설계는 변경과 관련된 것이다. 설계의 유용성은 변경의 &lt;strong&gt;방향성&lt;/strong&gt;과 &lt;strong&gt;발생 빈도&lt;/strong&gt;에 따라 결정된다. 설계에 요구되는 변경의 압력이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;타입 추가&lt;/code&gt;에 관한 것인지, 아니면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오퍼레이션 추가&lt;/code&gt;에 관한 것인지에 따라 달라진다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;타입 추가&lt;/strong&gt;라는 변경의 압력이 더 강한 경우에는 객체지향의 손을 들어줘야 한다. 이에 반해 변경의 주된 압력이 &lt;strong&gt;오퍼레이션을 추가&lt;/strong&gt;하는 것이라면 추상 데이터 타입의 승리를 선언해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;협력이-중요하다&quot;&gt;협력이 중요하다&lt;/h3&gt;

&lt;p&gt;설계할 때 객체가 참여할 협력을 결정하고 협력에 필요한 &lt;strong&gt;책임을 수행&lt;/strong&gt;하기 위해 어떤 객체가 필요한지에 관해 고민하라. 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화하라. &lt;strong&gt;타입 계층과 다형성&lt;/strong&gt;은 협력이라는 문맥 안에서 &lt;strong&gt;책임을 수행하는 방법&lt;/strong&gt;에 관한 고민한 결과물이어야 한다.&lt;/p&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><category term="Study" /><category term="Object" /><category term="OOP" /><category term="UML" /><category term="Study" /><category term="요약" /><category term="정리" /><summary type="html">Object 7장 요약</summary></entry><entry><title type="html">[Object] 6장</title><link href="http://localhost:4000/study/object-chapter6/" rel="alternate" type="text/html" title="[Object] 6장" /><published>2020-05-20T00:00:00+09:00</published><updated>2020-05-20T00:00:00+09:00</updated><id>http://localhost:4000/study/object-chapter6</id><content type="html" xml:base="http://localhost:4000/study/object-chapter6/">&lt;h1 id=&quot;6-메시지와-인터페이스&quot;&gt;6. 메시지와 인터페이스&lt;/h1&gt;

&lt;p&gt;클래스라는 &lt;strong&gt;구현 도구&lt;/strong&gt;에 지나치게 집착하면 경직되고 유연하지 못한 설계에 이를 확률이 높아진다. 훌량한 객체지향 코드를 얻기 위해서는 &lt;strong&gt;객체&lt;/strong&gt;를 지향해야 한다. 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다. 중요한 것은 책임이 객체가 수신할 수 있는 &lt;strong&gt;메시지&lt;/strong&gt;의 기반이 된다는 것이다.&lt;/p&gt;

&lt;p&gt;객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 &lt;strong&gt;주고받는 메시지&lt;/strong&gt;다. 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억해라. 객체가 수신하는 메시지들이 객체의 &lt;strong&gt;퍼블릭 인터페이스&lt;/strong&gt;를 구성한다.&lt;/p&gt;

&lt;h2 id=&quot;협력과-메시지&quot;&gt;협력과 메시지&lt;/h2&gt;

&lt;h3 id=&quot;클라이언트-서버-모델&quot;&gt;클라이언트-서버 모델&lt;/h3&gt;

&lt;p&gt;협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다. 메시지는 객체 사이의 협력을 가능하게 하는 매개체다.
두 객체 사이의 협력 관계를 설명하기 위해 사용되는 전통적인 메타포는 &lt;strong&gt;클라이언트-서버(Client-Server) 모델&lt;/strong&gt;이다. 협력 안에서 메시지를 전송하는 객체를 &lt;strong&gt;클라이언트&lt;/strong&gt;, 메시지를 수신하는 객체를 &lt;strong&gt;서버&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다. 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다. 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;메시지와-메시지-전송&quot;&gt;메시지와 메시지 전송&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;메시지(message)&lt;/strong&gt; 는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
메시지는 &lt;strong&gt;오퍼레이션명(operation name)&lt;/strong&gt; 과 &lt;strong&gt;인자(argument)&lt;/strong&gt; 로 구성되며 메시지 전송은 여기에 &lt;strong&gt;메시지 수신자&lt;/strong&gt;를 추가한 것이다.&lt;/p&gt;

&lt;h3 id=&quot;메시지와-메서드&quot;&gt;메시지와 메서드&lt;/h3&gt;

&lt;p&gt;메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 &lt;strong&gt;메서드&lt;/strong&gt;라고 부른다. 코드 상에서 동일한 이름의 변수에게 &lt;strong&gt;동일한 메시지&lt;/strong&gt;를 전송하더라도 객체의 타입에 따라 실행되는 &lt;strong&gt;메서드&lt;/strong&gt;가 달라질 수 있다. &lt;strong&gt;전통적인 방식&lt;/strong&gt;은 코드의 의미가 컴파일 시점과 실행 시점에 동일하다. 반면 &lt;strong&gt;객체&lt;/strong&gt;는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점을 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.&lt;/p&gt;

&lt;p&gt;메시지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수밖에 없다.
메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다. 메시지 전송자는 자신이 &lt;strong&gt;어떤 메시지를 전송해야 하는지만&lt;/strong&gt; 알면 된다. 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체의 결합도를 &lt;strong&gt;낮춤&lt;/strong&gt;으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.&lt;/p&gt;

&lt;h3 id=&quot;퍼블릭-인터페이스와-오퍼레이션&quot;&gt;퍼블릭 인터페이스와 오퍼레이션&lt;/h3&gt;

&lt;p&gt;객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 &lt;strong&gt;퍼블릭 인터페이스&lt;/strong&gt;라고 부른다. 퍼블릭 인터페이스에 포함된 메시지를 &lt;strong&gt;오퍼레이션(operation)&lt;/strong&gt; 이라고 부른다. 오퍼레이션은 수행 가능한 어떤 행동에 대한 &lt;em&gt;추상화&lt;/em&gt;다.&lt;/p&gt;

&lt;p&gt;퍼블릭 인터페이스와 메시지의 관점에서 보면 ‘메서드 호출’보다는 &lt;strong&gt;‘오퍼레이션 호출’&lt;/strong&gt; 이라는 용어를 사용하는 것이 더 적절하다.&lt;/p&gt;

&lt;h3 id=&quot;시그니처&quot;&gt;시그니처&lt;/h3&gt;

&lt;p&gt;오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 &lt;strong&gt;시그니쳐(signature)&lt;/strong&gt; 라고 부른다. 메서드는 이 시그니처에 구현을 더한 것이다. 다형성의 축복을 받기 위해서는 하나의 오퍼레이션에 대한 다양한 메서드를 구현해야만 한다. 객체의 퍼블릭 인터페이스가 &lt;strong&gt;객체의 품질&lt;/strong&gt;을 결정하기 때문에 결국 &lt;strong&gt;메시지&lt;/strong&gt;가 객체의 품질을 결정한다고 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;인터페이스와-설계-품질&quot;&gt;인터페이스와 설계 품질&lt;/h2&gt;

&lt;p&gt;좋은 인터페이스는 &lt;strong&gt;최소한의 인터페이스&lt;/strong&gt;와 &lt;strong&gt;추상적인 인터페이스&lt;/strong&gt;라는 조건을 만족해야한다. 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다. 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지 표현한다.&lt;/p&gt;

&lt;p&gt;최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 &lt;strong&gt;책임 주도 설계 방법&lt;/strong&gt;을 따르는 것이다. 메시지를 먼저 선택함으로써 협력과는 무관한 &lt;strong&gt;오퍼레이션이 인터페이스에 스며드는 것을 방지한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;디미터-법칙&quot;&gt;디미터 법칙&lt;/h3&gt;

&lt;p&gt;협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 &lt;strong&gt;디미터 법칙(Law of Demeter)&lt;/strong&gt; 이다. 디미터 법칙을 간단하게 요약하면 객체 내부 구조에 강하게 결합되지 않도록 &lt;strong&gt;협력 경로를 제한&lt;/strong&gt;하라는 것이다.&lt;/p&gt;

&lt;p&gt;디미터 법칙은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;낯선 자에게 말하지 말라(don't talk to strangers)&quot;&lt;/code&gt; 또는 `“오직 인접한 이웃하고만 말하라(only talk to your immediate neighbors)”로 요약할 수 있다.&lt;/p&gt;

&lt;p&gt;디미터 법칙을 따르면 &lt;strong&gt;부끄럼타는 코드(shy code)&lt;/strong&gt; 를 작성할 수 있다. 부끄럼타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다. 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다.
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMovie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDiscountConditions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같은 코드를 &lt;strong&gt;기차 충돌(train wreck)&lt;/strong&gt; 이라고 부른다. 기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.&lt;/p&gt;

&lt;p&gt;디미터 법칙은 객체가 자기 자신을 책임지는 &lt;strong&gt;자율적인 존재&lt;/strong&gt;여야 한다는 사실을 강조한다. 또한, 객체의 내부 구조를 묻는 메시지가 아니라 &lt;strong&gt;수신자에게 무언가를 시키는 메시지&lt;/strong&gt;가 더 좋은 메시지라고 속삭인다.&lt;/p&gt;

&lt;h3 id=&quot;묻지말고-시켜라&quot;&gt;묻지말고 시켜라&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;묻지말고 시켜라(Tell, Don’t Ask)&lt;/strong&gt; 는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야한다는 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다.&lt;/p&gt;

&lt;p&gt;객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다. 묻지 말고 시켜라 원칙에 따르도록 메시지를 결장하다보면 자연스럽게 &lt;strong&gt;정보 전문가&lt;/strong&gt;에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.&lt;/p&gt;

&lt;p&gt;상태를 묻는 오퍼레이션을 &lt;strong&gt;행동을 요청하는 오퍼레이션&lt;/strong&gt;으로 대체함으로써 인터페이스를 향상시켜라. 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 &lt;strong&gt;묻지 말고 시켜라&lt;/strong&gt; 원칙과 &lt;strong&gt;디미터 법칙&lt;/strong&gt;을 머리속에 떠올리는 것은 퍼블릭 인터페이스의 품질을 향상시킬 수 있는 좋은 습관이다.&lt;/p&gt;

&lt;h3 id=&quot;의도를-드러내는-인터페이스&quot;&gt;의도를 드러내는 인터페이스&lt;/h3&gt;

&lt;p&gt;메서드를 명명하는 두 가지 방법이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것이다.&lt;/li&gt;
  &lt;li&gt;‘어떻게’가 아니라 ‘무엇’을 하는지를 드러내는 것이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;무엇을 하는지 드로내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다. 이것은 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만든다.&lt;/p&gt;

&lt;p&gt;어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 &lt;strong&gt;의도를 드러내는 선택자(Intention Revealing Selector)&lt;/strong&gt; 라고 부른다.&lt;/p&gt;

&lt;p&gt;에릭 에반스는 켄트 백의 &lt;strong&gt;의도를 드러내는 선택자&lt;/strong&gt;를 인터페이스 레벨로 확장한 &lt;strong&gt;의도를 드러내는 인터페이스(Intention Revealing Interface)&lt;/strong&gt; 를 제시했다. 의도를 드러내는 인터페이스는 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관계된 의도만을 표현해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;원칙의-함정&quot;&gt;원칙의 함정&lt;/h2&gt;

&lt;p&gt;원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라.&lt;/p&gt;

&lt;h3 id=&quot;디미터-법칙은-하나의-도트를-강제하는-규칙이-아니다&quot;&gt;디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;IntStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;distinct&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 디미터 법칙을 위반하지 않는다. 디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 &lt;strong&gt;객체의 내부 구조&lt;/strong&gt;가 &lt;strong&gt;외부로 노출&lt;/strong&gt;되는 경우로 한정된다. 기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.&lt;/p&gt;

&lt;h2 id=&quot;명령-쿼리-분리-원칙&quot;&gt;명령-쿼리 분리 원칙&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;명령-쿼리 분리(Command-Query Separation) 원칙&lt;/strong&gt;은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.&lt;/p&gt;

&lt;p&gt;어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 &lt;strong&gt;루틴(routine)&lt;/strong&gt; 이라고 부른다. 루틴은 다시 &lt;strong&gt;프로시저(procedure)&lt;/strong&gt; 와 &lt;strong&gt;함수(function)&lt;/strong&gt; 로 구분할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.&lt;/li&gt;
  &lt;li&gt;함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;명령(Command)&lt;/strong&gt; 과 &lt;strong&gt;쿼리(Query)&lt;/strong&gt; 는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다.
명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다. &lt;strong&gt;어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령-쿼리 분리 원칙을 한 문장으로 표현하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;질문이 답변을 수정해서는 안 된다.&quot;&lt;/code&gt;는 것이다. 명령은 상태를 변경할 수 있지만 상태를 반환해서는 안 된다. 쿼리는 객체의 상태를 반환할 수 있지만 상태를 변경해서는 안된다.&lt;/p&gt;

&lt;p&gt;마틴 파울러(Martin Fowler)는 명령-쿼리 분리 원칙에 따라 작성된 객체의 인터페이스를 &lt;strong&gt;명령-쿼리 인터페이스(Command-Query Interface)&lt;/strong&gt; 라고 부른다.&lt;/p&gt;

&lt;h3 id=&quot;명령-쿼리-분리와-참조-투명성&quot;&gt;명령-쿼리 분리와 참조 투명성&lt;/h3&gt;

&lt;p&gt;명령과 쿼리를 엄격하게 분류하면 객체의 부수효과를 제어하기 수월해진다.
&lt;strong&gt;참조 투명성(referential transparency)&lt;/strong&gt; 이라는 특성을 잘 활용하면 버그가 적고, 디버깅이 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다. 참조 투명성이란 “어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성”을 의미한다.&lt;/p&gt;

&lt;p&gt;명령-쿼리 분리 원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다.&lt;/p&gt;

&lt;h3 id=&quot;책임에-초점을-맞춰라&quot;&gt;책임에 초점을 맞춰라&lt;/h3&gt;

&lt;p&gt;책임 주도 설계 방법에 따라 메시지가 객체를 결정하게 하라.&lt;/p&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><category term="Study" /><category term="Object" /><category term="OOP" /><category term="UML" /><category term="Study" /><category term="요약" /><category term="정리" /><summary type="html">Object 6장 요약</summary></entry><entry><title type="html">[Object] 5장</title><link href="http://localhost:4000/study/object-chapter5/" rel="alternate" type="text/html" title="[Object] 5장" /><published>2020-05-20T00:00:00+09:00</published><updated>2020-05-20T00:00:00+09:00</updated><id>http://localhost:4000/study/object-chapter5</id><content type="html" xml:base="http://localhost:4000/study/object-chapter5/">&lt;h1 id=&quot;5-책임-할당하기&quot;&gt;5. 책임 할당하기&lt;/h1&gt;

&lt;p&gt;책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 &lt;strong&gt;어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다&lt;/strong&gt;는 것이다. 책임 할당 과정은 일종의 &lt;strong&gt;트레이드오프&lt;/strong&gt; 활동이다.&lt;/p&gt;

&lt;h2 id=&quot;책임-주도-설계를-향해&quot;&gt;책임 주도 설계를 향해&lt;/h2&gt;

&lt;p&gt;데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서는 다음의 두 가지 원칙을 따라야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터보다 행동을 먼저 결정하라&lt;/li&gt;
  &lt;li&gt;협력이라는 문맥 안에서 책임을 결정하라&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터보다-행동을-먼저-결정하라&quot;&gt;데이터보다 행동을 먼저 결정하라&lt;/h3&gt;

&lt;p&gt;객체의 데이터에서 행동으로 무게 중심을 옮겨야 한다.
가장 기본적인 해결 방법은 &lt;strong&gt;객체를 설계하기 위한 질문의 순서&lt;/strong&gt;를 바꾸는 것이다.
책임 중심의 설계에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;이 객체가 수행해야 하는 책임은 무엇인가&quot;&lt;/code&gt;를 결정한 후에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;이 책임을 수행하는 데 필요한 데이터는 무엇인가&quot;&lt;/code&gt;를 결정한다.&lt;/p&gt;

&lt;h3 id=&quot;협력이라는-문맥-안에서-책임을-결정하라&quot;&gt;협력이라는 문맥 안에서 책임을 결정하라&lt;/h3&gt;

&lt;p&gt;책임은 객체의 입장이 아니라 객체가 참여하는 &lt;strong&gt;협력&lt;/strong&gt;에 적합해야 한다.
&lt;strong&gt;협력에 적합한 책임&lt;/strong&gt;이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미한다. 협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후에 메시지를 선택하는 것이 아니라 메시지를 결정한 후에 객체를 선택해야 한다.&lt;/p&gt;

&lt;p&gt;메시지가 &lt;strong&gt;클라이언트의 의도&lt;/strong&gt;를 표현한다는 사실에 주목하라.
클라이언트는 단지 임의의 객체가 메시지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메시지를 전송할 뿐이다. 메시지를 수신하기로 결정된 객체는 메시지를 처리할 &lt;strong&gt;책임&lt;/strong&gt;을 할당받게 된다.&lt;/p&gt;

&lt;h3 id=&quot;책임-주도-설계&quot;&gt;책임 주도 설계&lt;/h3&gt;

&lt;p&gt;책임 주도 설계의 흐름은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.&lt;/li&gt;
  &lt;li&gt;시스템 책임을 더 작은 책임으로 분할한다.&lt;/li&gt;
  &lt;li&gt;분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.&lt;/li&gt;
  &lt;li&gt;객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.&lt;/li&gt;
  &lt;li&gt;해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;책임-할당을-위한-grasp-패턴&quot;&gt;책임 할당을 위한 GRASP 패턴&lt;/h2&gt;

&lt;p&gt;크레이그 라만(Craig Larman)이 패턴 형식으로 제안한 &lt;strong&gt;GRASP 패턴&lt;/strong&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;General Responsibility Assignment Software Pattern(일반적인 책임 할당을 위한 소프트웨어 패턴)&lt;/code&gt;의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.&lt;/p&gt;

&lt;h3 id=&quot;도메인-개념에서-출발하기&quot;&gt;도메인 개념에서 출발하기&lt;/h3&gt;

&lt;p&gt;설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용하다. 어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 &lt;strong&gt;도메인 개념&lt;/strong&gt;이다. 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다.&lt;/p&gt;

&lt;h3 id=&quot;정보-전문가에게-책임을-할당하라&quot;&gt;정보 전문가에게 책임을 할당하라&lt;/h3&gt;

&lt;p&gt;책임 주도 설계 방식의 첫 단계는 애플리케이션이 제공해야 하는 기능을 &lt;strong&gt;애플리케이션의 책임&lt;/strong&gt;으로 생각하는 것이다. 메시지는 메시지를 수신할 객체가 아니라 메시지를 &lt;strong&gt;전송할 객체의 의도&lt;/strong&gt;를 반영해서 결정해야 한다.&lt;/p&gt;

&lt;p&gt;객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다. GRASP에서는 이를 &lt;strong&gt;INFORMATION EXPERT(정보 전문가)&lt;/strong&gt; 패턴이라고 부른다. INFORMATION EXPERT 패턴을 따르면 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화를 유지할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 스스로 처리할 수 없는 작업이 있다면 &lt;strong&gt;외부&lt;/strong&gt;에 도움을 요청해야 한다. 연쇄적인 메시지 전송과 수신을 통해 &lt;strong&gt;협력 공동체&lt;/strong&gt;가 구성되는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;높은-응집도와-낮은-결합도&quot;&gt;높은 응집도와 낮은 결합도&lt;/h3&gt;

&lt;p&gt;책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 것이 좋다.
GRASP에서는 이를 &lt;strong&gt;LOW COUPLING(낮은 결합도)&lt;/strong&gt; 패턴과 &lt;strong&gt;HIGH COHESION(높은 응집도)&lt;/strong&gt; 패턴이라고 부른다.&lt;/p&gt;

&lt;h4 id=&quot;low-coupling-패턴&quot;&gt;LOW COUPLING 패턴&lt;/h4&gt;

&lt;p&gt;어떻게 하면 의존성을 낮추고 &lt;strong&gt;변화의 영향&lt;/strong&gt;을 줄이며 &lt;strong&gt;재사용성&lt;/strong&gt;을 증가시킬 수 있을까? 설계의 전체적인 결합도가 낮게 유지도되록 책임을 할당하라.&lt;/p&gt;

&lt;h4 id=&quot;high-cohesion-패턴&quot;&gt;HIGH COHESION 패턴&lt;/h4&gt;

&lt;p&gt;어떻게 &lt;strong&gt;복잡성&lt;/strong&gt;을 관리할 수 있는 수준으로 유지할 것인가? 높은 응집도를 유지할 수 있게 책임을 할당하라.&lt;/p&gt;

&lt;h3 id=&quot;창조자에게-객체의-생성-책임을-할당하라&quot;&gt;창조자에게 객체의 생성 책임을 할당하라&lt;/h3&gt;

&lt;p&gt;GRASP의 &lt;strong&gt;CREATOR(창조자)&lt;/strong&gt; 패턴은 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.&lt;/p&gt;

&lt;h4 id=&quot;creator-패턴&quot;&gt;CREATOR 패턴&lt;/h4&gt;

&lt;p&gt;객체 A를 생성해야 할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가? 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;B가 A 객체를 포함하거나 참조한다.&lt;/li&gt;
  &lt;li&gt;B가 A 객체를 기록한다.&lt;/li&gt;
  &lt;li&gt;B가 A 객체를 긴밀하게 사용한다.&lt;/li&gt;
  &lt;li&gt;B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다(이 경우 B는 A에 대한 정보 전문가다)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구현을-통한-검증&quot;&gt;구현을 통한 검증&lt;/h2&gt;

&lt;h3 id=&quot;discountcondition-개선하기&quot;&gt;DiscountCondition 개선하기&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountCondition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountConditionType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DayOfWeek&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dayOfWeek&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocalTime&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTIme&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocalTIme&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountConditionType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PERIOD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedByPeriod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedBySequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedByPeriod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dayOfWeek&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getWhenScreened&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDayOfWeek&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getWhenScreened&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toLocalTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;endTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAfter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getWhenScreened&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toLocalTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isSatisfiedBySequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Screening&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;screening&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;가장 큰 문제점은 변경에 취약한 클래스를 포함하고 있다는 것이다.
DiscountCondition은 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다. 낮은 응집도가 초래하는 문제를 해결하기 위해서는 &lt;strong&gt;변경의 이유에 따라 클래스를 분리해야한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;코드를 통해 변경의 이유를 파악할 수 있는 첫 번째 방법은 &lt;strong&gt;인스턴스 변수가 초기화되는 시점&lt;/strong&gt;을 살펴보는 것이다. 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다. &lt;strong&gt;함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;코드를 통해 변경의 이유를 파악할 수 있는 두 번째 방법은 &lt;strong&gt;메서드들이 인스턴스 변수를 사용하는 방식&lt;/strong&gt;을 살펴보는 것이다. 이 경우 클래스의 응집도를 높이기 위해서는 &lt;strong&gt;속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;다형성을-통해-분리하기&quot;&gt;다형성을 통해 분리하기&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;역할&lt;/strong&gt;을 사용하면 객체의 구체적인 타입을 추상화할 수 있다.
객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당해야 한다. GRASP에서는 이를 &lt;strong&gt;POLYMORPHISM(다형성)&lt;/strong&gt; 패턴이라고 부른다.&lt;/p&gt;

&lt;h3 id=&quot;변경으로부터-보호하기&quot;&gt;변경으로부터 보호하기&lt;/h3&gt;

&lt;p&gt;변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서는 &lt;strong&gt;PROTECTED VARIATIONS(변경 보호)&lt;/strong&gt; 패턴이라고 부른다. PROTECTED VARIATIONS 패턴은 책임 할당의 관점에서 캡슐화를 설명한 것이다.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라.&quot;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;변경과-유연성&quot;&gt;변경과 유연성&lt;/h3&gt;

&lt;p&gt;설계를 주도하는 것은 &lt;strong&gt;변경&lt;/strong&gt;이다. 개발자로서 변경에 대비할 수 있는 두 가지 방법이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계한다.&lt;/li&gt;
  &lt;li&gt;코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만든다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;새로운 할인 정책이 추가될 때마다 인스턴스를 생성하고, 상태를 복사하고, 식별자를 관리하는 코드를 추가하는 일은 번거로울뿐만 아니라 오류가 발생하기도 쉽다. 이 경우 코드의 복잡성이 높아지더라도 할인 정책의 변경을 쉽게 수용할 수 있게 코드를 유연하게 만드는 것이 더 좋은 방법이다. 해결 방법은 상속 대신 &lt;strong&gt;합성&lt;/strong&gt;을 사용하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;유연성&lt;/strong&gt;은 의존성 관리의 문제다. 요소들 사이의 의존성의 정도가 유연성의 정도를 결정한다.&lt;/p&gt;

&lt;h2 id=&quot;책임-주도-설계의-대안&quot;&gt;책임 주도 설계의 대안&lt;/h2&gt;

&lt;p&gt;책임과 객체 사이에 방황할 때 돌파구를 찾기 위해 선택하는 방법은 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하는 것이다. 일단 실행되는 코드를 얻고 난 후에 코드 상에 명확하게 드러나는 책임들을 올바른 위치로 이동시키는 것이다.
이처럼 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것을 &lt;strong&gt;리팩터링(Refactoring)&lt;/strong&gt; 이라고 부른다.&lt;/p&gt;

&lt;h3 id=&quot;메서드-응집도&quot;&gt;메서드 응집도&lt;/h3&gt;

&lt;p&gt;긴 메서드는 다양한 측면에서 코드의 유지보수에 부정적인 영향을 미친다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는 데 너무 많은 시간이 걸린다.&lt;/li&gt;
  &lt;li&gt;하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.&lt;/li&gt;
  &lt;li&gt;메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다.&lt;/li&gt;
  &lt;li&gt;로직의 일부만 재사용하는 것이 불가능하다.&lt;/li&gt;
  &lt;li&gt;코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마이클 패더스(Michael Feathers)는 이런 메서드를 &lt;strong&gt;몬스터 메서드(monster method)&lt;/strong&gt; 라고 부른다.&lt;/p&gt;

&lt;p&gt;주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높여라. 코드를 작은 메서드들로 분해하면 전체적인 흐름을 이해하기도 쉬워진다.&lt;/p&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><category term="Study" /><category term="Object" /><category term="OOP" /><category term="UML" /><category term="Study" /><category term="요약" /><category term="정리" /><summary type="html">Object 5장 요약</summary></entry><entry><title type="html">[Object] 4장</title><link href="http://localhost:4000/study/object-chapter4/" rel="alternate" type="text/html" title="[Object] 4장" /><published>2020-05-20T00:00:00+09:00</published><updated>2020-05-20T00:00:00+09:00</updated><id>http://localhost:4000/study/object-chapter4</id><content type="html" xml:base="http://localhost:4000/study/object-chapter4/">&lt;h1 id=&quot;4-설계-품질과-트레이드-오프&quot;&gt;4. 설계 품질과 트레이드 오프&lt;/h1&gt;

&lt;p&gt;객체지향 설계의 핵심은 &lt;strong&gt;역할, 책임, 협력&lt;/strong&gt;이다. 그 중 객체지향 애플리케이션 전체의 품질을 결정하는 것은 &lt;strong&gt;책임&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;객체지향 설계&lt;/strong&gt;란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다. 이 정의에는 객체지향 설계에 관한 두 가지 관점이 섞여 있다. 첫 번째는 객체지향 설계의 핵심이 책임이라는 것이다. 두 번째는 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;훌륭한 설계&lt;/b&gt;란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것이다. 적절한 비용안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성된다. 이러한 설계를 위해서는 &lt;strong&gt;객체의 상태가 아니라 객체의 행동에 초점을 맞춰야&lt;/strong&gt;한다. 객체를 단순한 데이터의 집합으로 바라보는 시각은 객체 내부 구현을 퍼블릭 인터페이스에 노출시키는 결과를 낳기 때문에 결과적으로 설계가 변경에 취약해진다.&lt;/p&gt;

&lt;h2 id=&quot;데이터-중심의-영화-예매-시스템&quot;&gt;데이터 중심의 영화 예매 시스템&lt;/h2&gt;

&lt;p&gt;객체지향 설계에서는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;상태를 분할의 중심축으로 삼는 방법&lt;/li&gt;
  &lt;li&gt;책임을 분할의 중심축으로 삼는 방법&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;데이터 중심&lt;/strong&gt;의 관점에서 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다.
&lt;strong&gt;책임 중심&lt;/strong&gt;의 관점에서 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다.&lt;/p&gt;

&lt;p&gt;객체의 상태는 &lt;strong&gt;구현&lt;/strong&gt;에 속한다. 구현은 불안정하기 때문에 변하기 쉽다.
데이터에 초점을 맞추는 설계는 변경에 취약할 수 밖에 없다.&lt;/p&gt;

&lt;h3 id=&quot;데이터를-준비하자&quot;&gt;데이터를 준비하자&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;책임 중심&lt;/strong&gt;의 설계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;책임이 무엇인가&lt;/code&gt;를 묻는 것으로 시작한다면 &lt;strong&gt;데이터 중심&lt;/strong&gt;의 설계는 객체가 내부에 저장해야 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터가 무엇인가&lt;/code&gt;를 묻는 것으로 시작한다.
&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/82863263-aa3aa880-9f5c-11ea-8e06-32a68456e8bd.png&quot; alt=&quot;4.1.png&quot; /&gt;
&lt;i&gt;&lt;b&gt;그림 4.1&lt;/b&gt; 영화 예매 시스템 구현을 위한 데이터 클래스&lt;/i&gt;&lt;/p&gt;

&lt;h2 id=&quot;설계-트레이드오프&quot;&gt;설계 트레이드오프&lt;/h2&gt;

&lt;h3 id=&quot;캡슐화&quot;&gt;캡슐화&lt;/h3&gt;

&lt;p&gt;상태와 행동을 하나의 객체 안에 모으는 이유는 &lt;strong&gt;객체의 내부 구현을 외부로부터 감추기 위해서&lt;/strong&gt;다.
변경될 가능성이 높은 부분을 &lt;strong&gt;구현&lt;/strong&gt;이라고 부르고 상대적으로 안정적인 부분을 &lt;strong&gt;인터페이스&lt;/strong&gt;라고 부른다. 객체를 설계하기 위한 가장 기본적인 아이디어는 &lt;strong&gt;변경의 정도&lt;/strong&gt;에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다.&lt;/p&gt;

&lt;p&gt;객체지향에서 가장 중요한 원리는 &lt;strong&gt;캡슐화&lt;/strong&gt;다. 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다.&lt;/p&gt;

&lt;p&gt;설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.
정리하면 &lt;strong&gt;캡슐화&lt;/strong&gt;란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다. 변경될 수 있는 어떤 것이라도 캡슐화해야한다.&lt;/p&gt;

&lt;h3 id=&quot;응집도와-결합도&quot;&gt;응집도와 결합도&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;응집도&lt;/strong&gt;는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 모듈 내의 요소들이 &lt;strong&gt;하나의 목적&lt;/strong&gt;을 위해 긴말하게 협력한다면 그 모듈은 높은 응집도를 가진다.
&lt;strong&gt;결합도&lt;/strong&gt;는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다. 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다.&lt;/p&gt;

&lt;p&gt;좋은 설계란 &lt;strong&gt;높은 응집도&lt;/strong&gt;와 &lt;strong&gt;낮은 결합도&lt;/strong&gt;를 가진 모듈로 구성된 설계를 의미한다. 또한, 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.&lt;/p&gt;

&lt;p&gt;변경의 관점에서 응집도란 &lt;strong&gt;변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도&lt;/strong&gt;로 측정할 수 있다.
응집도가 높은 설계에서는 하나의 요구사항을 변경하기 위해 오직 하나의 모듈만 수정하면 된다. 반면 응집도가 낮은 설계에서는 하나의 원인에 의해 변경해야 하는 부분이 다수의 모듈에 분산돼 있기 때문에 여러 모듈을 동시에 수정해야 한다.&lt;/p&gt;

&lt;p&gt;결합도는 &lt;strong&gt;한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도&lt;/strong&gt;로 측정할 수 있다.
내부 구현을 변경했을 때 이것이 다른 모듈에 영향을 미치는 경우에는 두 모듈 사이의 결합도가 높다고 표현한다.&lt;/p&gt;

&lt;h2 id=&quot;데이터-중심의-영화-예매-시스템의-문제점&quot;&gt;데이터 중심의 영화 예매 시스템의 문제점&lt;/h2&gt;

&lt;p&gt;데이터 중심의 설계가 가진 대표적인 문제점을 다음과 같이 요약할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;캡슐화 위반&lt;/li&gt;
  &lt;li&gt;높은 결합도&lt;/li&gt;
  &lt;li&gt;낮은 응집도&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캡슐화-위반&quot;&gt;캡슐화 위반&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Movie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setFee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Money&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fee&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;getFee 메서드와 setFee 메서드는 Movie 내부에 Money 타입의 fee라는 이름의 인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러낸다.&lt;/p&gt;

&lt;p&gt;앨런 홀럽(Allen Holub)은 접근자와 수정자에 과도하게 의존하는 설계 방식을 &lt;strong&gt;추측에 의한 설계(design-by-guessing strategy)&lt;/strong&gt; 이라고 부른다.&lt;/p&gt;

&lt;h3 id=&quot;높은-결합도&quot;&gt;높은 결합도&lt;/h3&gt;

&lt;p&gt;데이터 중심 설계는 객체의 캡슐화를 약화시키기 때문에 클라이언트가 객체의 구현에 강하게 결합된다.
결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점은 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/82863265-aad33f00-9f5c-11ea-9886-f54b69f145d3.png&quot; alt=&quot;4.2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;i&gt;&lt;b&gt;그림 4.2&lt;/b&gt; 너무 많은 대상에 의존하기 때문에 변경에 취약한 ReservationAgency&lt;/i&gt;&lt;/p&gt;

&lt;h3 id=&quot;낮은-응집도&quot;&gt;낮은 응집도&lt;/h3&gt;

&lt;p&gt;서로 다른 이유로 변경되는 코드가 하나의 모듈안에 공존할 때 모듈의 응집도가 낮다고 말한다.
ReservationAgency를 예로 들어 변경과 응집도 사이의 관계를 살펴보자. 아마 다음과 같은 수정사항이 발생하는 경우에 ReservationAgency의 코드를 수정해야 할 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;할인 정책이 추가될 경우&lt;/li&gt;
  &lt;li&gt;할인 정책별로 할인 요금을 계산하는 방법이 변경될 경우&lt;/li&gt;
  &lt;li&gt;할인 조건이 추가되는 경우&lt;/li&gt;
  &lt;li&gt;할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우&lt;/li&gt;
  &lt;li&gt;예매 요금을 계산하는 방법이 변경될 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 된다.&lt;/li&gt;
  &lt;li&gt;하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자율적인-객체를-향해&quot;&gt;자율적인 객체를 향해&lt;/h2&gt;

&lt;h3 id=&quot;캡슐화를-지켜라&quot;&gt;캡슐화를 지켜라&lt;/h3&gt;

&lt;p&gt;객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다.
객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;스스로-자신의-데이터를-책임지는-객체&quot;&gt;스스로 자신의 데이터를 책임지는 객체&lt;/h3&gt;

&lt;p&gt;우리가 상태와 행동을 객체라는 하나의 단위로 묶은 이유는 &lt;strong&gt;객체 스스로 자신의 상태를 처리&lt;/strong&gt;할 수 있게 하기 위해서다.
객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 &lt;strong&gt;오퍼레이션&lt;/strong&gt;이 더 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/37808594/82863269-ab6bd580-9f5c-11ea-96cc-b7ab27da32de.png&quot; alt=&quot;4.3.png&quot; /&gt;
&lt;i&gt;&lt;b&gt;그림 4.3&lt;/b&gt; 결합도 측면에서 그림 4.2보다 개선된 설계&lt;/i&gt;&lt;/p&gt;

&lt;h2 id=&quot;데이터-중심-설계의-문제점&quot;&gt;데이터 중심 설계의 문제점&lt;/h2&gt;

&lt;p&gt;데이터 중심의 설계가 변경에 취약한 이유는 두 가지다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.&lt;/li&gt;
  &lt;li&gt;데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-중심-설계는-객체의-행동보다는-상태에-초점을-맞춘다&quot;&gt;데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다&lt;/h3&gt;

&lt;p&gt;데이터를 먼저 결정하고 데이터를 처리하는데 필요한 &lt;strong&gt;오퍼레이션&lt;/strong&gt;을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 &lt;strong&gt;인터페이스&lt;/strong&gt;에 고스란히 드러나게 된다. 결과적으로 객체의 인터페이스는 구현을 캡슐화하는 데 실패하고 코드는 변경에 취약해진다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-중심-설계는-객체를-고립시킨-채-오퍼레이션을-정의하도록-만든다&quot;&gt;데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.&lt;/h3&gt;

&lt;p&gt;협력이라는 문맥 안에서 필요한 &lt;strong&gt;책임&lt;/strong&gt;을 결정하고 이를 수행할 적절한 객체를 결정하는 것이 가장 중요하다.
올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 &lt;strong&gt;외부&lt;/strong&gt;에 맞춰져 있어야 한다.
안타깝게도 데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부로 향한다.&lt;/p&gt;</content><author><name>anstjaos</name><email>moonseo.kim@nhn.com</email></author><category term="Study" /><category term="Object" /><category term="OOP" /><category term="UML" /><category term="Study" /><category term="요약" /><category term="정리" /><summary type="html">Object 4장 요약</summary></entry></feed>