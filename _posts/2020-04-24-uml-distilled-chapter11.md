---
title: "[UML Distilled] 11장"
excerpt: "UML Distilled 11장 요약"

categories:
 - Study
tags:
 - UML
 - Study
 - 요약
 - 정리
---



# 11장. 액티비티 다이어그램

* **액티비티 다이어그램(activity diagram)** 은 순차 로직(procedural logic), 업무 절차(business process), 워크 플로우(work flow)를 기술하는 방법이다.
* 플로우 차트와 비슷한 역할을 하지만, 근본적인 차이점은 액티비티 다이어그램은 **병렬 행동(parallel behavior)** 을 지원한다는 것이다.

![11.1.png](https://i.imgur.com/p87Hr45.png)
<br><i>**그림 11.1** 간단한 액티비티 다이어그램</i>

* 액티비티 다이어그램은 **초기 노드(initial node)** 액션으로부터 시작해서 작업을 시작한다.
* **포크(fork)** 는 하나의 들어오는 플로우와 여러 개의 나가는 동시 플로우를 가지고 있다.
* 그림 11.1에서 **주문서 작성**과 **송장 발송**에 이어지는 액션들이 병렬로 일어난다.
* 액티비티 다이어그램은 작업을 수행하는 사람이 그것에 필요한 순서를 선택할 수 있다.
* 액티비티 다이어그램은 반드시 따라야 하는 **필수적인 순서**를 나타낼 뿐이다.
* 독립 스레드가 병렬로 작업을 하는 **동시 알고리즘(concurrent algorithm)** 에도 유용하게 쓰인다.
* **조인(join)** 으로 들어오는 플로우가 모두 조인에 도달해야 나가는 플로우로 진행한다.
* 액티비는 일련의 액션을 말하므로, 액티비티 다이어그램은 액션으로 구성된 액티비티이다.
* 조건 행동은 **결정(decision)과 병합(merge)** 으로 나타낸다.



## 액션을 분해하기

![11.2.png](https://i.imgur.com/uu7xIcY.png)
<br><i>**그림 11.2** 보조 액티비티 다이어그램</i>

* 액션은 하위 액티비티들로 분해될 수 있다. 이것을 하나의 액션으로 부를 수가 있다.
* 하위 액티비티에는 갈퀴 심볼을 붙인다.

![11.3.png](https://i.imgur.com/BJbkYET.png)
<br><i>**그림 11.3** 그림 11.1의 액티비티를 수정하여 그림 11.2의 액티비티를 호출하도록 한 예</i>



## 파티션

* 액티비티 다이어그램에는 누가 어떤 일을 하는지는 나타나지 않는다.
* **프로그래밍 관점**에서 보면, 다이어그램이 어떤 클래스가 어떤 액션을 수행하는지를 알려 주지 않는다.
* **비즈니스 프로세스 모델링 관점**에서는, 조직의 어떤 부분이 액션을 수행하는지를 말해주지 않는다.
* 누가 무엇을 하는지 보여주고 싶다면, 여러 개의 **파티션(partition)** 으로 나눌 수 있다.
* 파티션은 한 클래스나 조직 단위가 어떤 액션을 수행하는지를 보여 준다.

![11.4.png](https://i.imgur.com/NL7rrk7.png)
<br><i>**그림 11.4** 액티비티 다이어그램에서 파티션</i>



## 시그널

* **시간 시그널(time signal)** 은 시간의 흐름에 따라서 발생한다.

![11.5.png](https://i.imgur.com/U4msrhM.png)
<br><i>**그림 11.5** 액티비티 다이어그램의 시그널</i>

* **시그널**은 액티비티가 외부의 프로세스로부터 이벤트를 수신함을 나타낸다.

![11.6.png](https://i.imgur.com/2qFrbeJ.png)
<br><i>**그림 11.6** 시그널의 전송과 수신</i>



## 토큰

* 시작 노드가 토큰을 생성하고 다음 액션으로 그것을 보내면, 다음 액션에서 실행하고 그 다음 액션으로 보낸다.
* 토큰을 동전이나 원판이 다이어그램 안에서 돌아다니는 것으로 시각화할 수 있다.



## 플로우와 엣지

* 두 액션의 연결을 표헌하기 위해서 **플로우(flow)와 엣지(edge)** 라는 용어를 같은 의미로 사용한다.
* 가장 단순한 엣지는 토큰을 전달하는데, 이는 제어의 흐름을 의미할 뿐이다.
* 엣지는 객체로 전달할 수 있는데, 객체는 토큰의 역할을 하면서 데이터를 운반한다.

![11.7.png](https://i.imgur.com/utXO8eU.png)
<br>

<i>**그림 11.7** 엣지를 나타내는 네 가지 방법</i>



## 핀과 변형

* 액티비티 다이어그램에 매개변수에 대한 정보를 표현하려면 **핀(pin)** 을 사용하면 된다.
* 나가는 쪽 액션의 출력 매개변수와 들어가는 쪽 입력 매개변수가 일치하도록 해야한다.
* 이것이 일치하지 않는 경우에는 **변형(transformation)** (그림 11.8)을 표시하면 된다.
* 출력 핀의 쿼리는 필수적으로 입력 핀의 타입과 동일한 객체를 가져오는 쿼리여야 한다.

![11.8.png](https://i.imgur.com/tZryUJY.png)
<br><i>**그림 11.8** 플로우상에서의 변형</i>



## 확장 영역

* 한 액션의 출력이 다른 액션을 여러 번 호출하는 경우에 **확장 영역(expanssion region)** 을 사용하는 것이 좋다.
* 확장 영역은 컬렉션의 모든 아이템에 대해서 액션이 한 번씩 일어나는 영역을 의미한다.

![11.9.png](https://i.imgur.com/EOWwcmj.png)
<br><i>**그림 11.9** 확장 영역</i>

![11.10.png](https://i.imgur.com/4jKXBcX.png)
<br><i>**그림 11.10** 확장 영역 내의 단일 액션을 줄여서 표현한 예</i>



## 플로우 끝

* **플로우 끝(flow final)** 은 전체 액티비티를 중단시키지 않으면서 특정한 한 플로우를 끝내는 것을 표현한다.

![11.11.png](https://i.imgur.com/MtNRlQm.png)
<br><i>**그림 11.11** 액티비티에서의 플로우 끝</i>



## 조인 조건

* **조인**은 모든 입력 플로우가 조인에 도착했을 때 나가는 방향의 플로우를 실행한다.

![11.12.png](https://i.imgur.com/bvjw2Ad.png)
<br><i>**그림 11.12** 조인 조건</i>

* **조인 조건(join specification)** 은 조인에 붙는 부울린 표현이다.
* 도착할 때마다 조인 조건을 검사하여, 참인 경우에는 출력 토큰이 발생된다.



## 언제 액티비티 다이어그램을 사용하는가

* 액티비티 다이어그램의 큰 장점은, **병렬 행동(parallel behavior)** 을 지원하며 또 장려한다는 사실이다.
* 워크 플로우와 프로세스 모델링에 좋은 툴이 된다.