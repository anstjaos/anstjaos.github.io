---

title: "[UML Distilled] 5장"
excerpt: "UML Distilled 5장 요약"

categories:
 - Study
tags:
 - UML
 - Study
 - 요약
 - 정리
---



# 5장. 클래스 다이어그램 : 고급 개념

## 키워드

* 심볼이 너무 많으면 사용자가 모든 심볼의 의미를 기억하기가 아주 힘들다.
* UML을 사용할 때는 종종 심볼의 개수를 줄이고 **키워드(keyword)** 를 사용한다.



## 책임

* 클래스 다이어그램에서 클래스의 책임을 나타내는 것이 좋을 때가 있다.
* 가장 좋은 방법은 클래스 내부에 주석문으로 나타내는 것이다.

![5-1](https://i.imgur.com/n862OkR.png)<br>

<i>**그림 5.1** 클래스 다이어그램에서 책임을 나타낸 예 </i>



## 정적 오퍼레이션과 속성

* **정적(static)** : 인스턴스가 아닌 클래스에 적용되는 오퍼레이션이나 속성
* 정적 속성은 클래스 다이어그램에서 **밑줄**이 그어진다.

![5-2](https://i.imgur.com/lpBeNus.png)<br>

<i>**그림 5.2** 정적 오퍼레이션 표기법</i>



## 집합과 합성

* **집합(aggregation)**
    * **'일부분이 되는'** 관계이다.
    * 사용하지 않는 것을 권한다.

![5-3](https://i.imgur.com/P5atJED.png)<br>

<i>**그림 5.3** 집합</i>

* **합성(composition)**
    * 하나의 클래스는 다른 많은 클래스의 컴포넌트가 될 수 있지만, 하나의 인스턴스는 단 하나의 소유자를 가져야한다.
    * 어떤 인스턴스라도 그 소유자로 단 하나의 객체만을 가진다.
    * **"공유 불가"**

![5-4](https://i.imgur.com/X6K9pjv.png)<br>

<i>**그림 5.4** 합성</i>



## 파생 프로퍼티

* **파생 프로퍼티(derived property)** 는 다른 값들을 기초로 계산할 수 있는 것이다.
* 소프트웨어 관점에서 몇 가지 다른 방법으로 해석될 수 있다.
* 값들 사이의 제약을 가리키는 것이다.

![5-5](https://i.imgur.com/6m5azTK.png)<br>

<i>**그림 5.5** 기간에 대한 파생 속성의 예</i>



## 인터페이스와 추상 클래스

* **추상 클래스(abstract class)** 란 직접 인스턴스화 될 수 없는 클래스이다.
* 한 개 이상의 추상 오퍼레이션을 가진다.
* **추상 오퍼레이션(abstract operation)** 은 구현을 가지고 있지 않다.
* UML에서 추상 클래스나 오퍼레이션을 표시하는 흔한 방법은 *이텔릭체*로 표시하는 것이다.
* **인터페이스(interface)** 는 구현이 없는 클래스이다.
* 클래스는 인터페이스에 대해서 **'제공하는'** 과 **'필요로 하는'** 이라는 두 가지 관계를 가지고 있다.
    * 클래스가 인터페이스를 대신할 수 있는 경우, 그것은 **인터페이스를 제공하는 클래스**이다.
    * 작동을 하기 위해서 인터페이스의 인스턴스가 필요하다면 그것은 **인터페이스를 필요로 하는 클래스**이다.

![5-6](https://i.imgur.com/HTC991V.png)<br>

<i>**그림 5.6** 인터페이스와 추상 클래스를 Java로 나타낸 예</i>

* 그림 5.7에서의 표기법은 막대 사탕(lollipop)으로 불린다.

![5.7](https://i.imgur.com/h1iOZGD.png)<br>

<i>**그림 5.7** 공 - 소켓 표기법</i>



## 읽기 전용과 동결

* {readOnly} 키워드는 클라이언트가 읽을 수만 있고 수정할 수 없는 프로퍼티에 사용한다.
* 어떤 프로퍼티를 수정할 수 없을 때에 그 프로퍼티가 **동결(frozen)** 되었다고 하며, **불변(immutable)** 이라고도 불린다.



## 참조 객체와 값 객체

* 객체는 **고유성(identity)** 을 가지고 있다.
* 고유성이 참조 객체에는 중요하지만 값 객체에 대해서는 그렇게 중요하지 않다.
* **참조 객체(reference object)** 는 참조나 포인터를 사용한다.
* 만약 하나의 클래스에 대한 참조가 두 개 있고 그것들이 같은지를 알고 싶으면 보통 고유성을 비교한다.
* **값 객체(value object)** 란 값을 사용한다.
* 만약 두 개의 날짜가 같은지를 비교하고 싶다면 고유성을 보는 것이 아니라 그것들이 나타내는 값을 본다.
* 값 객체의 값 자체는 불변이어야 한다.
* 만약 다른 객체의 날짜를 예상하지 못한 방법으로 변경할 경우 문제가 발생한다. 이 문제를 **별명(aliasing)** 이라고 한다.



## 한정 연관

* **한정 연관(qualified association)** 은 관계 배열, 맵, 해쉬, 딕셔너리와 같은 프로그래밍 개념과 동등한 의미이다.

![5-8](https://i.imgur.com/IOew94i.png)<br>

<i>**그림 5.8** 한정 연관</i>



## 클래스화와 일반화

* **일반화(generalization)** 는 이행적(transitive)이지만 **클래스화(classification)** 는 그렇지 않다.
* 클래스화 다음에 일반화가 오면 합칠 수 있지만 반대의 경우는 아니다.
* UML에서는 일반화를 표기하기 위해서 일반화 심볼을 사용한다.
* 클래스화를 표현하려면 \<\<instantiate\>\> 키워드와 함께 의존을 이용한다.



## 다중 클래스화와 동적 클래스화

* **클래스화**는 객체와 객체의 타입 간의 관계를 뜻한다.
* **단일 클래스화(single classification)** 에서는 한 객체가 단일 타입에 속한다.
* **다중 클래스화(multiple classification)** 에서는 객체가 반드시 상속 관계일 필요는 없는 몇 개의 타입으로 정의될 수 있다.
    * 다중 클래스화는 특정한 타입을 정의하지 않고 한 객체가 여러 가지의 타입일 수 있도록 허용한다.
    * **다중 클래스화**를 사용할 경우, 어떤 조합이 적법한지에 대해서 확실히 알고 있어야 한다.
    * UML 2에서는 각각의 일반화 관계를 **일반화 집합(generalization set)** 에 넣는 방법으로 이것을 행한다.
    * 일반화 집합은 기본적으로 분리형(disjoint)이다. 상위 타입의 어떤 인스턴스라도 해당 집합 내의 하위 타입 중 오직 하나의 인스턴스만이 될 수가 있다.

![5-9](https://i.imgur.com/JsD9taY.png)<br>

<i>**그림 5.9** 다중 클래스화</i>



* **동적 클래스화(dynamic classification)** 는 하위 타입 구조 안에서 객체가 클래스를 바꿀 수 있도록 허용하고, **정적 클래스화(static classification)** 는 그렇지 않다.



## 연관 클래스

* **연관 클래스(association class)** 는 그림 5.10과 같이 속성, 오퍼레이션 그리고 다른 기능들을 연관에 더할 수 있도록 한다.

![5-10](https://i.imgur.com/IpgQ2wK.png)<br>

<i>**그림 5.10** 연관 클래스</i>



![5-11](https://i.imgur.com/TS1BCOn.png)<br>

<i>**그림 5.11** 연관 클래스를 완전한 클래스로 만든 예</i>



* 연관에 참여하는 두 개의 객체 사이에 오직 하나의 연관 클래스 인스턴스만이 있을 수 있다.



![5-12](https://i.imgur.com/q7jDoql.png)<br>

<i>**그림 5.12** 연관 클래스의 미묘함(Role은 연관 클래스가 아니어야 한다)</i>

![5-13](https://i.imgur.com/IjKblfI.png)<br>

<i>**그림 5.13** 임시 관계를 위해 클래스를 사용한 예</i>

![5-14](https://i.imgur.com/6AWaaHD.png)<br>

<i>**그림 5.14** 연관에서 \<\<temporal\>\> 키워드를 사용한 예</i>



## 템플릿(매개변수) 클래스

* 몇 가지 언어는 **매개변수 클래스(parameterized class)** , 다른 말로 **템플릿(template)** 의 개념을 가지고 있다.
* 이 개념은 엄격한 타입의 언어(strongly typed language)에서 컬렉션을 사용할 때 가장 유용하다.
* Set와 같은 매개변수 클래스를 사용하는 것을 **파생(derivation)** 이라 한다.
* \<\<bind\>\> 키워드는 정련 관계(refinement relationship)의 스테레오 타입이다.

![5-15](https://i.imgur.com/ryRz2TO.png)<br>

<i>**그림 5.15** 템플릿 클래스</i>

![5-16](https://i.imgur.com/PW5WxTQ.png)<br>

<i>**그림 5.16** 결합 요소(버전 1)</i>

![5-17](https://i.imgur.com/dDvudCY.png)<br>

<i>**그림 5.17** 결합 요소(버전 2)</i>



## 열거

* **열거(enumeration)** 는 몇 가지 심볼 값 외에는 다른 프로퍼티를 갖지 않는 고정된 값 세트를 표현하는데 사용된다.

![5-18](https://i.imgur.com/zHsw1Rl.png)<br>

<i>**그림 5.18** 열거</i>



## 활성 클래스

* **활성 클래스(active class)** 란, 인스턴스들을 가지고 있으며 인스턴스들이 각각 자신의 제어 스레드를 실행하고 제어하는 클래스를 말한다.

![5-19](https://i.imgur.com/9HjcAGF.png)<br>

<i>**그림 5.19** 활성 클래스</i>



## 가시성

* **가시성(visibility)** 을 표현하는 약어는 네 가지가 있다.
  * \+ (public)
    * \- \(private\)
    * \~ (package)
    * \# \(protected\)